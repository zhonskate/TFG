%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                       CARREGA DE LA CLASSE DE DOCUMENT                      %
%                                                                             %
% Les opcions admissibles son:                                                %
%      12pt / 11pt            (cos dels tipus de lletra; no feu servir 10pt)  %
%                                                                             %
% catalan/spanish/english     (llengua principal del treball)                 %
%                                                                             % 
% french/italian/german...    (si necessiteu fer servir alguna altra llengua) %
%                                                                             %
% listoffigures               (El document inclou un Index de figures)        %
% listoftables                (El document inclou un Index de taules)         %
% listofquadres               (El document inclou un Index de quadres)        %
% listofalgorithms            (El document inclou un Index d'algorismes)      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[11pt,spanish,listoffigures]{tfgetsinf}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                     CODIFICACIO DEL FITXER FONT                             %
%                                                                             %
%    windows fa servir normalment 'ansinew'                                   %
%    amb linux es possible que siga 'latin1' o 'latin9'                       %
%    Pero el mes recomanable es fer servir utf8 (unicode 8)                   %
%                                          (si el vostre editor ho permet)    % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[utf8]{inputenc} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        ALTRES PAQUETS I DEFINICIONS                         %
%                                                                             %
% Carregueu aci els paquets que necessiteu i declareu les comandes i entorns  %
%                                          (aquesta seccio pot ser buida)     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{float}
\usepackage{glossaries}
\glstoctrue
\makeglossaries

\newglossaryentry{bug}
{
  name=bug,
  description={Problema en un programa de computador o sistema de software que desencadena un resultado indeseado}
}

\newglossaryentry{JSON}
{
  name=JSON,
  description={ Acrónimo de \textit{JavaScript Object Notation}, es un formato de texto ligero para el intercambio de datos. Más información en \url{https://es.wikipedia.org/wiki/JSON}}
}

\newglossaryentry{notebook}
{
  name=notebook,
  description={ Documentos que contienen tanto código como elementos de \textit{texto rico}, como figuras o tablas. Los notebooks son documentos tanto legibles como ejecutables.}
}

\newglossaryentry{handler}
{
  name=handler,
  description={ Rutina que opera de forma asíncrona y maneja los eventos recibidos en un programa}
}

\newglossaryentry{HTTP}
{
  name=HTTP,
  description={ acrónimo de \textit{Hypertext Transfer Protocol} es el protocolo de comunicación que permite las transferencias de información en la \textit{World Wide Web}}
}

\newglossaryentry{array}
{
  name=array,
  description={ Estructura de datos en forma de vector unidimensional que contiene una serie de elementos del mismo tipo}
}

\newglossaryentry{cookie}
{
  name=cookie,
  description={  Pequeña información enviada por un sitio web y almacenada en el navegador del usuario, de manera que el sitio web puede consultar la actividad previa del navegador}
}

\newglossaryentry{hash}
{
  name=hash,
  description={Función que tiene como entrada un conjunto de elementos, que suelen ser cadenas, y los convierte en un rango de salida finito, normalmente cadenas de longitud fija}
}

\newglossaryentry{callback}
{
  name=callback,
  description={Cualquier código ejecutable que se pasa como argumento a otro código, que lo llamará de vuelta (\textit{call back}) y ejecutará el argumento en un momento dado}
}

\newglossaryentry{JWT}
{
  name=JWT,
  description={Estándar abierto basado en \textit{JSON} propuesto para la creación de \textit{tokens} de acceso que permiten la propagación de identidad y privilegios o claims en inglés}
}

\newglossaryentry{token}
{
  name=token,
  description={Cadena de caracteres que tiene un significado coherente en cierto lenguaje de programación}
}

\newglossaryentry{scroll}
{
  name=scroll,
  description={Movimiento en 2D de los contenidos que conforman el escenario de un videojuego o la ventana que se muestra en una aplicación informática}
}

\newglossaryentry{flag}
{
  name=flag,
  description={ Uno o más bits que se utilizan para almacenar un valor binario o código que tiene asignado un significado}
}

\newglossaryentry{jquery}
{
  name=jquery,
  description={ biblioteca multiplataforma de \textit{JavaScript} que permite simplificar la manera de interactuar con los documentos \textit{HTML}}
}

\newglossaryentry{polling}
{
  name=polling,
  description={operación de consulta constante para crear una actividad sincrónica sin el uso de interrupciones}
}

\newglossaryentry{link}
{
  name=link,
  description={Elemento de un documento electrónico que permite acceder automáticamente a otro documento o a otra parte del mismo}
}

\setglossarystyle{altlisthypergroup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        DADES DEL TREBALL                                    %
%                                                                             %
% titol, alumne, tutor i curs academic                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Un entorno colaborativo para el diseño, desarrollo y compilación de notebooks de trabajo Jupyter compartidos. }
\author{Javier Rodríguez Domínguez}
\tutor{José Manuel Bernabeu Aubán}
\curs{2017-2018}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                     PARAULES CLAU/PALABRAS CLAVE/KEY WORDS                  %
%                                                                             %
% Independentment de la llengua del treball, s'hi han d'incloure              %
% les paraules clau i el resum en els tres idiomes                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\keywords{jupyter, notebooks, computació interactiva, col·laboració, anàlisi de dades, python} % Paraules clau 
         { jupyter, notebooks, computación interactiva, colaboración, análisis de datos, python }              % Palabras clave
         {jupyter, notebooks, interactive computation, collaboration, data analytics, python }        % Key words

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              INICI DEL DOCUMENT                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              RESUMS DEL TFG EN VALENCIA, CASTELLA I ANGLES                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
El treball realitzat ha consistit en la creació de un entorn col·laboratiu permissionat per a la computació interactiva. Com a punt de partida per al desenvolupament del projecte s'ha elegit \textit{Jupyter}. \textit{Jupyter} és una ferramenta per a la computació interactiva en diferents llenguatges  de programació. Ofereix una forma de treballar molt intuïtiva i visual, utilitzant documents interactius anomenats \textit{notebooks}. La plataforma \textit{Jupyter} s'utilitza molt en entorns d'anàlisi de dades i educació, on es pot treballar en grup, així que adaptar-la a un ámbit col·laboratiu pot ser molt interessant per als usuaris. Per a assolir el objectiu proposat s'han dut a terme una serie de tasques, com són la sincronització en temps real dels \textit{notebooks}, la implementació d'un sistema d'autenticació, autorització e identificació dels usuaris, la gestió dels \textit{notebooks} i, per últim, la creació d'una capa de persistència per a la plataforma. S'han emprat tecnologies com \textit{Tornado} per als serveis web, \textit{Auth0} per a l'autenticació i \textit{SQLite} com a sistema gestor de la base de dades, entre altres. S'ha obtés com a resultat del treball una aplicació que, comptant amb aspectes de millora, compleix totes les funcionalitats previstes de forma correcta.
\end{abstract}
\begin{abstract}[spanish]
El trabajo realizado ha consistido en la creación de un entorno colaborativo permisionado para la computación interactiva. Como punto de partida para el desarrollo del proyecto se ha elegido \textit{Jupyter}. \textit{Jupyter} es una herramienta para la computación interactiva en diferentes lenguajes de programación. Ofrece una forma de trabajar muy intuitiva y visual, utilizando documentos interactivos llamados \textit{notebooks}. La plataforma \textit{Jupyter} se utiliza mucho en entornos de análisis de datos y educación, donde se puede trabajar en grupo, así que adaptarla a un ámbito colaborativo puede ser muy interesante para los usuarios. Para alcanzar el objetivo propuesto se han llevado a cabo una serie de tareas, como son la sincronización en tiempo real de los \textit{notebooks}, la implementación de un sistema de autenticación, autorización e identificación de los usuarios, la gestión de los \textit{notebooks} y, por último, la creación de una capa de persistencia para la plataforma. Se ha hecho uso de tecnologías como \textit{Tornado} para los servicios \textit{web}, \textit{Auth0} para la autenticación y \textit{SQLite} como sistema gestor de la base de datos, entre otras. Se ha obtenido como resultado del trabajo una aplicación que, contando con aspectos de mejora, cumple todas las funcionalidades previstas de forma correcta.
\end{abstract}
\clearpage
\begin{abstract}[english]
This project has consisted on the creation of a collaborative and permission-based environment for the interactive computation. \textit{Jupyter} has been chosen as a starting point for the development of the project. \textit{Jupyter} is a tool for interactive computation in several programming languages. It offers a very visual and intuitive way of working, using interactive documents called notebooks. The \textit{Jupyter} platform is widely used on data analytics and education environments, where working in groups is possible, so adapting it to a collaborative ambit can be very interesting to its users. In order to reach the proposed objective several tasks have been carried out. For example the real-time synchronization of the notebooks, the implementation of a authentication, authorization and identification system for the users,  the notebook management and the creation of a persistence layer for the platform. The following technologies have been used: \textit{Tornado} for the web services, \textit{Auth0} for the authentication and \textit{SQLite} as the managing system for the database, amongst others.  As a result of the project we have obtained an application that, having room for improvement, fulfills all the planned functionalities successfully.

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              CONTINGUT DEL TREBALL                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  INTRODUCCIO                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Introducci\'on}
\label{ch:intro}

Los entornos de computación interactiva permiten llevar a cabo tareas de programación de manera intuitiva e inmeditata. Al ofrecer un entorno responsivo, el usuario puede realizar cambios y ver su resultado al instante, haciendo que el flujo de interacción entre él y la herramienta sea muy ágil.

Existe un gran tradición en el ámbito de la computación interactiva, siendo los primeros ejemplos terminales o \textit{shells}. Éstos suelen ofrecer una interfaz mediante línea de comandos. Para encontrar herramientas que soporten entornos gráficos hay que avanzar hasta el uso de \textit{\gls{notebook}s}, documentos donde los bloques de código y los resultados de sus computaciones conviven en un una serie de celdas.

Existe un gran numero de plataformas que hacen uso de este sistema de notebooks, desde su introducción en 1988 con \textit{Mathematica}\footnote{https://www.wolfram.com/mathematica/}. Algunos ejemplos son \textit{Maple} \footnote{https://www.maplesoft.com/}, \textit{Matlab}\footnote{https://www.mathworks.com/products/matlab.html} o \textit{Jupyter}\footnote{http://jupyter.org/}. Es este último en el que se va a centrar el desarrollo del proyecto, que consistirá en la creación de un entorno colaborativo para su uso concurrente por más de un usuario, ya que no se ofrece de forma nativa en la plataforma. Para aquellos que no conozcan la herramienta, se va a realizar una breve introducción:

\textit{Jupyter } es una herramienta para la programación interactiva en diferentes lenguajes. Nace como la sucesión natural de \textit{IPython} \textit{(Interactive Python)}. Se trata de un programa que extendía las funcionalidades de la propia terminal de \textit{Python} con la intención de que su uso fuera más interactivo. Más adelante, este proyecto pasaría a utilizar un sistema de \textit{notebooks}. La estructura del \textit{notebook} es bastante sencilla. Internamente es un documento \textit{\gls{JSON}}, con bloques denominados celdas, los cuales tienen una entrada \textit{(input)} y una salida \textit{(output)}. Para que el \textit{notebook} sea legible, se visualiza de una manera ordenada, mostrando sólo el código y los resultados obtenidos al usuario y haciendo que el uso de la herramienta sea lo más fluido posible.   
Esta mejora sería bastante significativa, pues se podía mantener una persistencia entre sesiones, ya que los \textit{notebooks} pueden ser guardados y cargados. El siguiente paso fué saltar al proyecto \textit{Jupyter}, cuyo cambio más importante fué la posibilidad de trabajar con lenguajes diferentes a \textit{Python}. Ésto se consigue desacoplando la lógica de la ejecución del código del servicio principal de edición de \textit{notebooks}. El código a ejecutar se manda a un proceso que lo recibe, lo ejecuta y lo devuelve. Estos procesos se llaman \textit{kernels}, y a día de hoy existen \textit{kernels} para más de 100 lenguajes que pueden ser utilizados con \textit{Jupyter}\footnote{https://github.com/jupyter/jupyter/wiki/Jupyter-kernels}.

Al no facilitar de manera nativa la colaboración entre usuarios, \textit{Jupyter} deja la posibilidad de trabajar mandando el \textit{notebook} entre los diferentes autores a medida que se va modificando. Ésto es un método poco eficiente, principalmente por dos razones. En primer lugar, \textit{Jupyter} tiene una mala interacción con los servicios de control de versiones, pues el usuario modifica las celdas, pero realmente lo que cambia es el \textit{JSON} interno. La herramienta de control de versiones busca los cambios entre estos documentos \textit{JSON}, y encuentra muchas más diferencias de las que se realizaron por los usuarios, pues ellos sólo alteraron las celdas, pero internamente estos cambios se representaron de una forma mucho más extensa. Ésto supone problemas en cuanto a la usabilidad de este control de versiones, pues los cambios no son fácilmente legibles. 
Por otro lado, \textit{Jupyter} es ampliamente utilizado en entornos de análisis de datos. En estas circunstancias, se suele trabajar con grandes cantidades de información, que tiene que ser cargada y procesada. Cuando se comparte un \textit{notebook}, se comparte sólo el \textit{JSON} que lo forma, no el estado de ejecución del \textit{kernel}. Esto quiere decir que cada vez que alguien quiere hacer una prueba con los datos, tiene que procesarlos y cargarlos en memoria, computaciones que pueden ser bastante costosas.

En resumen, trabajar de forma colaborativa haciendo uso de \textit{Jupyter} a día de hoy es una tarea complicada debido a la naturaleza de la plataforma, y, al ser muy utilizada en este tipo de situaciones, plantea un problema que puede ser de gran ayuda resolver.


% MOTIVACIÓN

\section{Motivaci\'on}
\label{sec:motivacion}

El trabajo se ha llevado a cabo dentro del ámbito de unas prácticas de empresa en el Instituto Tecnológico de Informática\footnote{https://www.iti.es/}. Desde el instituto se realizaron una serie de propuestas interesantes para la realización de este Trabajo de Fin de Grado. La primera fué la adaptación de la base de datos \textit{RethinkDB} \footnote{https://www.rethinkdb.com/} para introducirla como un componente en un sistema de \textit{PaaS}. Por otro lado se planteó la creación de un entorno colaborativo para el diseño, desarrollo y compilación de notebooks de trabajo \textit{Jupyter} compartidos. Después de estudiar las dos opciones a fondo, me decanté por la segunda propuesta, pues ya había hecho uso de la plataforma y me había enfrentado a los problemas que supone utilizarla en un ámbito colaborativo.

\textit{Jupyter} es una plataforma que puede ser utilizada para diversos fines, ya que la manera que tiene de presentar el código y los resultados es muy visual. Ésto ha hecho que sea un recurso muy utilizado en entornos donde es importante entender qué hace cada trozo de código, como por ejemplo en la educación o en el análisis de datos. En estas situaciones se trabaja mucho en grupos, y la posibilidad de utilizar \textit{Jupyter} de manera colaborativa entre los miembros de estos grupos puede facilitar mucho el desarrollo de los proyectos.

Existen herramientas que proponen un \textit{Jupyter} colaborativo a través de internet, como \textit{Google Colab} \footnote{https://colab.research.google.com} o \textit{CoCalc} \footnote{https://cocalc.com/}. Estas plataformas permiten una edición de los \textit{notebooks} simultánea, haciendo que dos o más usuarios puedan modificar los contenidos del \textit{notebook} a la vez y sin control alguno. Este enfoque a un \textit{Jupyter} colaborativo no es el más adecuado, ya que puede resultar caótico. Un entorno con políticas más restrictivas en cuanto a la modificación de los documentos puede ser más acorde con el modelo de ejecución. Además, aunque estas herramientas previamente comentadas ofrecen planes gratuitos, el poder computacional de las máquinas que utilizan es muy bajo, haciendo que la interacción sea tosca y pesada. Si se quieren utilizar alternativas más potentes se aplicará el coste monetario correspondiente, por lo que proponer una alternativa propia permitirá utilizar las máquinas de las que se disponga.

A nivel personal, pienso que tomar como base para mi Trabajo de Fin de Grado un proyecto real ha sido muy beneficioso, ya que tengo la oportunidad de ver como se trabaja en entornos profesionales, y más concretamente en el ámbito real de un instituto tecnológico. Además, me tengo que enfrentar a problemas nuevos para mí, como el diseño de una arquitectura o la implementación de un servicio \textit{web}. 

En conclusión, la motivación para llevar a cabo este trabajo viene dada por el conocimiento de los problemas de la plataforma \textit{Jupyter} a la hora de utilizarla en ámbitos colaborativos; el interés por parte del Instituto Tecnológico de Informática en la realización del proyecto; la falta de alternativas que se adecuen a la visión que se tiene sobre la colaboración y el crecimiento a nivel personal y profesional que se pueda obtener.  


% OBJETIVOS

\section{Objetivos}
\label{sec:objetivos}

El objetivo principal del proyecto es el desarrollo de un entorno colaborativo permisionado dentro del ámbito de la computación interactiva. Se entiende desarrollo como todo el proceso creativo, desde la concepción de la idea y el diseño formal hasta la implementación final del código.

En cuanto a objetivos más acotados y específicos, se tienen los siguientes, cada uno con su correspondientes apartados de diseño e implementación:

\begin{itemize}

\item Permitir que los usuarios modifiquen y vean los cambios en los documentos en tiempo real.

\item Gestionar los usuarios, sus permisos y sus sesiones.

\item Gestionar los \textit{notebooks} y el acceso de los usuarios a estos \textit{notebooks}.

\item Soportar la colaboración en distintas sesiones de trabajo.

\end{itemize}

Estos objetivos específicos se pueden entender como pequeños apartados que, una vez unidos y cohesionados, supondrán el cumplimiento del objetivo principal.


% IMPACTO ESPERADO

\section{Impacto esperado}
\label{sec:impacto}

Se espera que la herramienta resultante facilite el uso de la computación interactiva en situaciones colaborativas, reduciendo el tiempo y esfuerzo empleado en poner en común los cambios que se vayan a realizar. También se pretende que se trabaje en tiempo real, agilizando todo el proceso de desarrollar la tarea en cuestión. 


% METODOLOGÍA

\section{Metodología}
\label{sec:metodologia}

La metodología seguida para el desarrollo del trabajo ha sido la siguiente. En primer lugar, se realizó un estudio de las herramientas similares a \textit{Jupyter} con el fin de situarla dentro del contexto tecnológico del momento. Después se realizó un estudio a fondo del código de la plataforma, para conseguir una visión general de su funcionamiento interno. Siguiendo los objetivos marcados, se ha procedido a realizar primero un diseño estructural de cada una de las partes. Este diseño se ha comparado con otros exhaustivamente para elegir el que mejor se adecuara al apartado tratado. Más tarde se procede a implementar la parte en base al diseño, y por último a hacer pruebas con el fin de encontrar fallos o \textit{\gls{bug}s} y poder solucionarlos.

En cuanto a la interacción con el tutor y compañeros en la empresa, se han realizado reuniones periódicas a lo largo del desarrollo del proyecto. Se han discutido los puntos a tratar y se han propuesto soluciones a los posibles problemas encontrados.


% ESTRUCTURA DE LA MEMORIA

\section{Estructura de la memoria}
\label{sec:estructura}

La memoria seguirá una estructura según la guías que ofrece la \textit{UPV}. Se comenzará hablando del estado del arte en el capítulo \ref{ch:state-of-art}, donde se hará una comparativa de \textit{Jupyter} con plataformas similares, en los capítulos \ref{ch:analisis-problema}, \ref{ch:diseno-solu} y \ref{ch:desarrollo-solucion} se planteará el problema, las diferentes soluciones propuestas para resolverlo, así como el diseño y desarrollo de éstas. En los dos capítulos siguientes, \ref{ch:implantacion} y \ref{ch:pruebas} se hablará de la implantación del sistema, cómo desplegarlo y ponerlo en marcha, así como de las pruebas realizadas a éste. Por último, se hará una conclusión del trabajo, exponiendo si se han alcanzado los objetivos y de qué manera, y se propondrán mejoras que se pueden llevar a cabo en un futuro, capítulos \ref{ch:conclusiones} y \ref{ch:futuro}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                       CAPITOLS                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                 ESTADO DEL ARTE                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Estado del arte}
\label{ch:state-of-art}

La programación interactiva es un recurso que se lleva utilizando desde la década de los 60. Los ejemplos más comunes para este tipo de modelo de funcionamiento son los intérpretes de comandos o \textit{shells}. Algunos lenguajes de programación que ofrecen una \textit{shell} con una interfaz de linea de comandos (\textit{CLI}) son \textit{Python} \footnote{https://www.python.org/}, \textit{JavaScript} \footnote{https://www.javascript.com/}, \textit{Ruby} \footnote{https://www.ruby-lang.org/en/} o \textit{Lisp} \footnote{https://es.wikipedia.org/wiki/Lisp}. Es éste último lenguaje en el que se origina el concepto que sirve como base para la programación interactiva basada en intérpretes de comandos. Se trata del \textit{REPL}, el bucle de Lectura-Evaluación-Impresión, en inglés \textit{Read-Eval-Print-Loop}. Este bucle está compuesto por la lectura de las expresiones introducidas por el usuario (\textit{Read}), la evaluación de estas expresiones por el intérprete (\textit{Eval}), la impresión de los resultados obtenidos (\textit{Print}) y, por último, se vuelve a aceptar una nueva entrada para ser computada cerrándose el bucle (\textit{Loop}). Se puede encontrar un estudio más amplio sobre el modelo de programación interactiva, y en concreto sobre \textit{Lisp} en el artículo de Erik Sandewall \cite{Sandewall}.

Aparte de las ventajas previamente comentadas sobre este modelo de programación basado en los \textit{shells}, se encuentran muchos defectos, como pueden ser la pérdida de información entre sesiones o la ausencia de \textit{rich output}, es decir la imposibilidad de mostrar resultados como imágenes o gráficos. Con la intención de solventar estos problemas, concretamente en el lenguaje \textit{Python}, en 2001 Fernando Pérez desarrolló la plataforma \textit{IPython} (\textit{Interactive Python}) \cite{ipython}. Esta plataforma extendía las funcionalidades del \textit{shell} por defecto de \textit{Python}, añadiendo algunas mejoras, como la posibilidad de mostrar la \textit{historia} (las instrucciones ejecutadas anteriormente) o la identificación de errores.

El siguiente paso en el desarrollo de \textit{Ipython} sería lograr la persistencia absoluta de los datos, ya no solo mediante el uso de la \textit{historia} sino utilizando un sistema de \textit{notebooks}. En 1988, Steve Wolfram desarrolla \textit{Mathematica} \cite{math}, un programa para la computación matemática. Brian Hayes realiza una breve introducción en \cite{th-mathematica}. Este programa fué el primero en implementar este sistema de \textit{notebooks}, que sería utilizado por \textit{Ipython} más tarde. Los \textit{notebooks} son documentos con celdas que sirven como entrada. El usuario puede escribir código en ellas y ejecutarlas, lo que dará un resultado que se mostrará en la parte inferior de la celda, es decir, la salida. Este sistema propone un enfoque muy visual e interactivo a los usuarios, pues pueden ver resultados parciales y hacer pruebas en fragmentos aislados de código. También es posible añadir texto explicativo del propósito del código e, incluso, explicando los resultados que se van obteniendo, porporcionando un verdadero documento vivo, muy útil en entornos de experimentación, como análisis de datos, o entornos formativos, por citar solo dos.

\textit{Ipython} había conseguido crear una plataforma interactiva para \textit{Python}, y se dieron cuenta de que ésta podia ser trasladada a más lenguajes. Fué entonces cuando se produjo\textit{ The big split} \footnote{https://blog.jupyter.org/the-big-split-9d7b88a031a7} (La gran partición) y nació \textit{Jupyter} \cite{jupyter-nb}. \textit{Jupyter} permitía la inclusión de nuevos lenguajes de programación en el \textit{frontend} de tipo \textit{notebook} que se había desarrollado. La tarea realizada para lograr ésto fué la de desacoplar el código de ejecución de \textit{Python} del \textit{frontend}. Se creó un protocolo que utilizaba mensajería \textit{ZeroMQ} \footnote{http://zeromq.org/} y que servía como un canal genérico para comunicarse con cualquier proceso de ejecución de otro programa \cite{wire-protocol}. Estos ``procesos'' reciben el nombre de \textit{kernels}.

Al igual que muchas de las \textit{shells} de lenguajes comentadas anteriormente, la de \textit{Python} hacía uso de un \textit{kernel} para la ejecución del código. Para la definición de \textit{kernel} se puede seguir la interprentación de Sandewall ``\textit{El kernel de un sistema de programación debe contener los siguientes programas: Un parser que transforma los programas del usuario a la representación interna. Un program-printer que realiza la operación contraria. Un intérprete para los programas en la representación interna y/o un compilador que transforma la estructura de datos interna en languaje máquina para ser computado}''\cite{Sandewall}. Por lo tanto, el \textit{kernel} deberá poder recibir la información, computarla y devolverla al programa principal.

De esta manera, cualquier programa que fuera capaz de recibir una entrada por medio del protocolo de \textit{Jupyter} y devolver una salida podía realizar la función de \textit{kernel}. Sin embargo, un \textit{kernel} que no mantenga el contexto entre las diferentes computaciones no sirve de mucho, pues no se podrá separar el código en celdas y que las variables mantengan sus valores. Al no poder separar el código, el concepto de \textit{notebook} pierde su sentido completamente, por lo que para que un \textit{kernel} sea útil debe mantener el contexto.

Para definir contexto, se hace referencia a Anind K. Dey and Gregory D. Abowd \cite{context} ``\textit{El contexto es cualquier información que puede ser utilizada para caracterizar la situación de una entidad. Una entidad es una persona, lugar o objeto que se considera relevante para la interacción entre un usuario y una aplicación, incluyendo el propio usuario y aplicación}''. Este contexto va a ser el entorno sobre el que se ejecute cada computación mandada a un \textit{kernel}, y tiene gran importancia dentro de cuaquier plataforma de programación interactiva.

Una vez comentados todos estos puntos y componentes dentro de \textit{Jupyter}, así como brevemente la historia de la plataforma, se pasará a estudiar otras aplicaciones que ofrecen una funcionalidad o servicio similares a ella:

\begin{itemize}

\item \textbf{\textit{Mathematica}}. Como se ha comentado previamente, \textit{Mathematica} es la plataforma en la que \textit{Jupyter} se inspira a la hora de realizar su salto al uso de \textit{notebooks}. Es una gran referencia en cuanto a programación interactiva, por todo el recorrido que presenta. Difiere con \textit{Jupyter} sobretodo en cuanto a versatilidad. Mientras que \textit{Mathematica} está muy centrado en la computación matemática, \textit{Jupyter} puede ser utilizado con una variedad mayor de fines, incluso se puede hacer uso de un \textit{kernel} de \textit{Mathematica} en \textit{Jupyter} \footnote{https://github.com/mmatera/iwolfram}.

\item \textbf{\textit{Apache Zeppelin}} \footnote{https://zeppelin.apache.org/}. Se trata de la alternativa de \textit{Apache} a \textit{Jupyter}. Funciona de manera muy parecida, pudiendo hacer uso de diferentes lenguajes para la computación. Implementa la interfaz de \textit{notebook}, con algunas mejoras, como por ejemplo poder hacer uso de formularios. También tiene integración con \textit{Apache Spark} \footnote{https://spark.apache.org/}, pudiendo realizar computaciones paralelas.

\end{itemize}

Se han mostrado alternativas a la plataforma \textit{Jupyter}, pero lo que se pretende alcanzar en el desarrollo del proyecto es poder hacer un uso colaborativo de uno de estos sistemas. En este momento, ya existen plataformas que permiten estas funcionalidades: 

\begin{itemize}

\item \textbf{\textit{Google Colab}} \footnote{https://colab.research.google.com/}. Es la opción que plantea \textit{Google} para la edición concurrente de notebooks \textit{Jupyter} por dos o más usuarios. Sigue el modelo de colaboración visto en \textit{Google Docs} \footnote{https://www.google.es/intl/es/docs/about/}, donde todos los usuarios pueden realizar modificaciones en todo el documento. Hace uso de \textit{Google drive} \footnote{https://www.google.com/intl/es\_ALL/drive/} para el almacenamiento de los \textit{notebooks} así como para la compartición.

\item \textbf{\textit{CoCalc}} \footnote{https://cocalc.com/}. Creado por la empresa \textit{Sagemath} Inc. ofrece un entorno colaborativo de computación matemática en la nube. Se hace uso de una estructura basada en proyectos, que se pueden compartir y en los que se pueden crear \textit{notebooks} de \textit{Jupyter} entre otros muchos tipos de documentos. La colaboración entre los usuarios dentro de éstos sigue el mismo modelo que \textit{Google colab}. El almacenamiento de los proyectos se realiza en la propia plataforma \textit{CoCalc}.

\item \textbf{\textit{Apache Zeppelin}}. \textit{Zeppelin} ofrece, a parte de todo lo comentado anteriormente, la colaboración haciendo uso de \textit{Google Drive} de forma nativa. Los modelos de almacenamiento, edición y compartición son los mismos que en el caso de \textit{Google colab}, pero siendo los documentos \textit{notebooks Zeppelin}.

\end{itemize}

En conclusión, \textit{Jupyter} nace como una evolución lógica dentro de la programación interactiva, mostrando una gran verstilidad y una infraestructura robusta. Introduce el \textit{frontend} de \textit{notebook} a muchos lenguajes, haciendo que puedan ser utilizados de una manera más visual. Se ha visto también que existen otras plataformas para la programación interactiva mediante \textit{notebooks}, así como algunas que incluso nos permiten hacerlo de manera colaborativa. En la sección \ref{sec:critica-estado} se mostrarán los aspectos que difieren con nuestra visión de colaboración para estas plataformas, y en la sección  \ref{sec:propuesta} se plantearán aquellas propuestas que se adapten a nuestro punto de vista.


% CRITICA AL ESTADO DEL ARTE

\section{Crítica al estado del arte}
\label{sec:critica-estado}

Tal y como se ha visto en el apartado anterior, existen plataformas que ya implementan entornos colaborativos utilizando el sistema de programación interactiva mediante \textit{notebooks}. 

Estos entornos ofrecen un modelo de edición y ejecución no permisionado, basado en el concepto de que los usuarios interactuen libremente a lo largo de todo el documento. En un entorno de edición de texto ésto funciona perfectamente, como es el caso de \textit{Google Docs}, ya que, aunque se borre alguna parte del documento creada por otro usuario, no hay dudas sobre el estado del documento, pues lo que se ve es lo que se tiene. Cuando se traslada ese modelo de edición a un entorno de programación interactiva, pueden surgir problemas relacionados sobretodo con el contexto del \textit{kernel} en el que se está realizando la ejecución.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\textwidth]{exec-jupy.png}
  \caption{Detalle sobre el modelo de ejecución de \textit{Jupyter}}
  \label{fig:ex-jup}
\end{figure}

Es el caso de los \textit{kernels} de \textit{Jupyter}, pues no siguen una ejecución coherente con el orden de celdas del \textit{notebook}, sino que funcionan siguiendo el orden de ejecución que dicta el usuario, o, en este caso, los usuarios. Al mandar una celda a ejecución, ésta se ejecuta en base al contexto del \textit{kernel} en ese momento. Se puede ver un ejemplo en la figura \ref{fig:ex-jup}, donde, siguiendo un orden secuencial empezando por la primera celda, el resultado de la segunda, ``\textit{k+k}'', debería ser 6. Sin embargo, al haberse ejecutado previamente la tercera celda, se altera el contexto, obteniendo 10 como resultado. Si en una sesión con dos usuarios cocurrentes uno realiza una ejecución a destiempo, puede alterar el contexto que esperaba otro usuario, modificando el resultado de su computación. 

Como el contexto del \textit{kernel} es oculto para los usuarios, la resolución de problemas es muy poco intuitiva, pues no se tiene porqué saber donde se encuentra el error. Esto puede resultar en una interacción tosca y compleja entre los usuarios y la plataforma.


%PROPUESTA

\section{Propuesta}
\label{sec:propuesta}

Para resolver los problemas que se plantean en la sección \ref{sec:critica-estado}, se tiene que seguir un modelo de edición y ejecución más restrictivo. En este proyecto se ha planteado una modelo permisionado que solo permite la edición del documento por un usuario a la vez. La colaboración se consigue pasando los permisos de modificación entre los diferentes usuarios. De esta manera, se consigue una ejecución secuencial de las celdas, y todos los usuarios conocen el estado del \textit{notebook} en todo momento, pues sólo uno está realizando cambios mientras el resto los observa en tiempo real.

En el caso de querer realizar una modificación del documento concurrente por dos o más usuarios habría que encontrar la manera de que éstos conocieran el contexto en el que su código va a ser ejecutado. También deberían ser avisados de los cambios realizados por el resto de usuarios así como de si éstos han modificado dicho contexto. De no cumplirse éstos puntos, se encontraría el mismo problema mencionado anteriormente, en el que no se puede tener la certeza de qué resultado va a devolver cada ejecución.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                             ANÁLISIS DEL PROBLEMA                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Análisis del problema}
\label{ch:analisis-problema}

Para conocer la dimensión del problema y poder realizar un análisis, se tiene que ahondar en la estructura interna de la plataforma que se va  a modificar, en este caso \textit{Jupyter}. De esta manera, se va a entender qué componentes están realizando qué función, y se podrán modificar de forma acorde a la solución que planteemos.


% ESTRUCTURA DE JUPYTER

\section{Análisis de \textit{Jupyter}}
\label{sec:analisis-jupyter}


\subsection{Estructura de \textit{Jupyter}}
\label{subsec:estructura-jupyter}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{jupy.png}
  \caption{Componentes de \textit{Jupyter Notebook}}
  \label{fig:components}
\end{figure}

La estructura básica de Jupyter se puede encontrar en la figura \ref{fig:components}. En ella identificamos los tres elementos principales que componen la plataforma: el servidor de \textit{notebooks "Notebook server"}, el archivo \textit{notebook "Notebook Store"} y el \textit{kernel}. 


\subsubsection{Servidor de \textit{notebooks}}
\label{subsec:estructura-servidor}

Es el servicio desplegado cuando se inicia la aplicación. Se accede a él a través de la conexión mediante un navegador. En este servidor se puede ver el directorio desde el cuál se ha lanzado el proceso y seleccionar cada uno de los archivos \textit{notebook} bien para visualizarlos y ejecutarlos o para realizar alguna otra acción como eliminarlos, renombrarlos, etc.
 También se puede ver en otra pestaña qué archivos están en ejecución, y detener su \textit{kernel} asociado.
 
Estructuralmente, el servidor de \textit{notebooks} es el proceso que sirve como nexo de unión entre el usuario y el \textit{notebook}, al que accederá y modificará. Implementa todas las conexiones entre el navegador y el \textit{notebook} (en este caso los \textit{\gls{handler}s} para las llamadas \textit{\gls{HTTP}}); así como las conexiones entre el \textit{notebook} y el \textit{kernel}, especificadas en la documentación de \textit{Jupyter}, más concretamente en \textit{The wire protocol} \cite{wire-protocol}, que utilizan la tecnología \textit{ZeroMQ}.

\begin{figure}[h]
	\centering
  	\includegraphics[width=\linewidth]{tree.png}
  	\caption{Interfaz del servidor de \textit{notebooks}}
  	\label{fig:tree}
\end{figure}

En la figura \ref{fig:tree} se puede ver una captura de la interfaz del servidor de \textit{notebooks}. Se puede identificar cada uno de los \textit{notebooks} en la lista, así como la pestaña \textit{running}, donde se podría detener la ejecución de los \textit{kernels} en marcha.


\subsubsection{Archivo \textit{notebook}}
\label{subsec:estructura-notebook}

Es el documento principal dentro de todo el ecosistema de \textit{Jupyter}. Toda la plataforma va enfocada a estos archivos, donde se encuentra el código y los resultados de los mismos. El \textit{notebook} se divide en celdas, que son las unidades de ejecución, es decir, al ejecutar una celda, se ejecuta solamente el contenido de ésta. Las celdas se dividen en dos secciones, una para la entrada, donde el usuario introduce el código; y otra para la salida, donde, en el caso de que el código ejecutado en la celda tenga una salida disponible, se mostrará el resultado de la ejecución. 

La función principal del \textit{notebook} es la persistencia, pues nos sirve para no perder el trabajo realizado, ya que al finalizar una sesión éste queda guardado en disco. Los \textit{notebooks} son internamente archivos \textit{JSON}, donde se encuentra una \textit{\gls{array}} de celdas, con sus respectivas entradas y salidas, así como los metadatos del mismo \textit{notebook}.

La ejecución del notebook se realiza haciendo uso de los \textit{kernels}, y se explicará más adelante, pues hace falta tener el concepto de \textit{kernel} dentro de la plataforma \textit{Jupyter} claro para entender su funcionamiento.

En la figura \ref{fig:notebook} se puede ver un ejemplo de \textit{notebook}. En ella se pueden apreciar detalles, como la posibilidad de mostrar celdas formateadas en \textit{markdown} \footnote{https://es.wikipedia.org/wiki/Markdown}, o el uso de \textit{rich output}, como se puede ver en el gráfico de la parte inferior.


\subsubsection{\textit{Kernel}}
\label{subsec:estructura-kernel}

Es el componente encargado de la ejecución del código dentro de la plataforma \textit{Jupyter}. Se trata de un proceso externo al servidor de \textit{notebooks} donde se manda, mediante \textit{ZeroMQ} e implementando \textit{The wire protocol} \cite{wire-protocol}, el segmento de código que se quiere ejecutar. El código será ejecutado en base al contexto (estado de las variables, funciones, etc.) que se tenga en el \textit{kernel} en ese momento, que vendrá determinado por las ejecuciones anteriores.

Existen \textit{kernels} para más de 100 lenguajes, así como herramientas para facilitar su desarrollo, pudiéndose hacer uso de recursos como el \textit{Wrapper} \footnote{http://jupyter-client.readthedocs.io/en/stable/wrapperkernels.html}, que implementa toda la mensajería que comunica el \textit{kernel} con el cliente.

\begin{figure}[H]
	\centering
  	\includegraphics[width=\linewidth]{notebook.png}
  	\caption{Ejemplo de \textit{notebook}}
  	\label{fig:notebook}
\end{figure}


\subsection{Modelo de ejecución}
\label{subsec:modelo-ejec}

Una vez explicados los elementos que componen la plataforma, se puede pasar a ver su modelo de ejecución. Funciona de la siguiente manera: El código que se encuentra dentro de la celda a ejecutar se manda al \textit{kernel}. Éste lo procesa en base a su contexto, es decir, el estado de las variables guardadas en el momento en el que se ejecuta la celda. Ésto quiere decir que si se ejecuta una celda con una numeración inferior más tarde que una con una numeración superior, la inferior se ejecutará en base a lo guardado por la superior. Por lo tanto, el orden de las celdas dentro del \textit{notebook} no tiene porqué corresponder con el orden en el que han sido ejecutadas, ya que el usuario es libre de ejecutar cada celda cuando quiera. Este modelo de ejecución puede resultar confuso, y hay que tenerlo en cuenta a la hora de buscar fallos en los resultados.

Por otro lado, cuando el \textit{kernel} detecta que los resultados se pueden mostrar de más de una manera, por ejemplo, en texto plano o con un gráfico, manda todas las salidas posibles hacia el cliente, y es éste el encargado de decidir cuál le va a mostrar al usuario. Esto se debe a que los \textit{kernels} no funcionan exclusivamente con \textit{notebooks}, sino que pueden ser utilizados con otros \textit{frontends}, como podrían ser terminales o otras aproximaciones, por ejemplo \textit{qtconsole} \footnote{https://ipython.org/ipython-doc/3/interactive/qtconsole.html}.


% FORMALIZACIÓN DEL PROBLEMA

\section{Formalización del problema}
\label{sec:formalizacion}

Tal y como se comentaba en la sección \ref{sec:objetivos}, la finalidad del proyecto es desarrollar un entorno que permita el uso colaborativo de \textit{Jupyter}. Para ello, se tienen que cumplir objetivos más pequeños y acotados, pues todos van a desempeñar un papel necesario para la funcionalidad de la plataforma obtenida. A continuación se expondrán, segmentándolos en tareas y entrando en detalles de porqué son necesarios para el proyecto.

\begin{itemize}

\item \textbf{Permitir que los usuarios modifiquen y vean los cambios en los documentos en tiempo real}. El aspecto general a derivar de este objetivo es la sincronización. Se necesita que las instancias de los documentos de los dos usuarios estén sincronizadas para cumplir este objetivo.

\item \textbf{Gestionar los usuarios, sus permisos y sus sesiones}. Para ello se va a necesitar un mecanismo de autenticación y autorización, así como un sistema de gestión de usuarios, para poder darlos de alta en la plataforma e identificarlos.

\item \textbf{Gestionar los \textit{notebooks} y el acceso de los usuarios a éstos}. Se va a necesitar una gestión de los \textit{notebooks}, así como hacer uso de la autorización previamente comentada para decidir si un usuario puede acceder o no al \textit{notebook} en cuestión.

\item \textbf{Soportar de colaboración en distintas sesiones de trabajo}. Para cumplir este objetivo va a hacer falta una capa de persistencia para mantener los datos necesarios.
\end{itemize}

Una vez se han visto los objetivos del proyecto y se han relacionado con tareas más concretas y abordables, se formalizan estas tareas y lo que se pretende conseguir con cada una de ellas. Serán los puntos a solucionar en la sección \ref{sec:ident-soluciones}:

\begin{itemize}
\item \textbf{Sincronización}. La sincronización es un aspecto fundamental para una herramienta colaborativa. Permite conocer el estado del documento, así como los cambios producidos por otros usuarios. 


\item \textbf{Autenticación, autorización e identificación}. Es necesario diseñar un sistema para ver quién está modificando los documentos y si tiene permisos para hacerlo, así como asegurarse de que no pueda hacerlo si no los tiene. Una vez identificados los usuarios, se puede saber con quién se está colaborando.

\item \textbf{Gestión de notebooks}. Hace falta una manera de poder añadir a nuevos usuarios a los documentos. No se puede  colaborar si no hay manera de que dos o más personas editen el mismo archivo.

\item \textbf{Persistencia}. Se necesita un mecanismo para mantener la identificación de los usuarios, así como sus roles y documentos asociados. De esta manera, no será necesario que se vuelva a compartir el documento cuando un usuario cierre la sesión y se vuelva a autenticar.

\end{itemize}


% ANÁLISIS DE LA SEGURIDAD

\section{Análisis de la seguridad}
\label{sec:analisis-seguridad}

Para garantizar a los usuarios que sus documentos no pueden ser vistos por personas no autorizadas, se ha de crear un modelo de seguridad en la plataforma. Éste debería estar muy relacionado con la autenticación y la persistencia, pues se quiere comprobar y asegurar que cada usuario pertenece a solamente una persona y de que estos usuarios van a ser guardados y persistidos para conexiones futuras.

\textit{Jupyter} implementa de base un sistema de seguridad, en el que se pueden proteger los servidores de \textit{notebooks} con una contraseña. Cualquier persona que conozca esta contraseña puede entrar al servidor. Este sistema no es suficiente para las especificaciones propuestas, porque no identifica al usuario. Se piensa en un servicio \textit{multi-tenant} en la nube compartiendo recursos computacionales, por lo tanto diferentes usuarios se van a conectar a la misma instancia del servidor. Se debe conocer qué usuario se está conectando en cada momento para poder servirle su configuración específica. Si se utilizara una instancia del servidor para cada usuario conectado se podría mantener el sistema propio de \textit{Jupyter}, pues no habría duda de quién se conecta, ya que sólo el dueño de la instancia tendría acceso a la contraseña.


% CASOS DE USO

\section{Casos de uso}
\label{sec:casos-uso}

\begin{figure}[H]
	\centering
  	\includegraphics[width=\linewidth]{UML.png}
  	\caption{Diagrama UML sobre los casos de uso}
  	\label{fig:UML}
\end{figure}

La figura \ref{fig:UML} nos muestra un diagrama UML \footnote{https://es.wikipedia.org/wiki/Lenguaje\_unificado\_de\_modelado} sobre las diferentes acciones que se deberían poder realizar en el sistema a desarrollar. Se puede apreciar una distinción clara entre las tres cajas existentes, donde se puede ver el nivel de profundidad en cuanto a permisos del que goza el actor. En la primera caja actúa un agente sin atuenticar (\textit{anónimo}). En la segunda, un agente autenticado pero sin un rol definido, pues no se encuentra en el contexto de un \textit{notebook} en concreto (\textit{usuario}). Por último, la tercera caja muestra agentes autenticados y con un rol en el contexto de un \textit{notebook}.  Las flechas indican la potestad de un actor para realizar una acción.

Un agente anónimo tiene la posibilidad de registrarse en la plataforma, en caso de no disponer de una cuenta, o bien de autenticarse. Una vez dentro de la plataforma se convierte en un usuario, el cual puede seleccionar un \textit{notebook}, del cual forme parte previamente, o bien crear un \textit{notebook} nuevo. En el caso de crear un \textit{notebook}, el usuario adquiriría el rol de Administrador-editor, únicamente para el \textit{notebook} creado. Por el contrario, en caso de seleccionar un \textit{notebook}, se asignaría al usuario el rol que tiene en el \textit{notebook} seleccionado, que puede ser cualquiera. Un usuario que se acaba de registrar en la plataforma no puede tener ningún notebook asignado, pues no se le puede invitar antes de que se dé de alta. Es por eso que nada más entrar en la plataforma solo tendría la opción de crear un \textit{notebook} nuevo, o podría esperar a ser invitado a otro.

Para que un usuario pueda acceder a un archivo \textit{notebook}, este usuario tiene que formar parte de él. Ésto se podría conseguir de dos formas, bien siendo el propio usuario el creador del archivo, o habiendo sido invitado a él. En el caso de ser el creador del archivo, recibiría el rol de Administrador-editor en un primer lugar, lo que le permitiría realizar modificaciones sobre el archivo, así como visualizarlo y gestionarlo. Dentro de la gestión encontraría las opciones de compartir, asignar editor, eliminar o renombrar el \textit{notebook}. Al compartir el archivo, el receptor de esta invitación entraría al documento como Espectador, permitiéndole tan solo la visualización del archivo. El Administrador-editor podría entonces asignar permisos de edición a cualquier usuario perteneciente al notebook, delegando la edición en él y convirtiéndose en Administrador. De esta manera la opción de asignar editor puede tener impacto en todos los roles.

% IDENTIFICACIÓN Y ANÁLISIS DE SOLUCIONES POSIBLES

\section{Identificación y análisis de soluciones posibles}
\label{sec:ident-soluciones}

De la misma manera que se han planteado y formalizado los problemas que se tienen que atacar durante la realización del proyecto, se van a identificar y analizar las posibles soluciones para cada uno de ellos. 


\subsection{Sincronización}
\label{subsec:sincro}

Para solucionar el problema de la sincronización se planteó, en una primera instancia, una sincronización por mensajería. Para ello, se haría uso de un componente llamado \textit{Connection Bridge}, que se encargaría de las conexiones entre el \textit{kernel} y los \textit{notebooks}, interceptando tanto los mensajes provenientes del \textit{notebook} que se está modificando, para mandarlos a las otras instancias y actualizarlas como los mensajes provenientes del \textit{kernel}, para que las salidas, o \textit{outputs}, se propaguen a todas las instancias de \textit{notebooks} conectadas. Se puede ver un esquema de su funcionamiento en la Figura \ref{fig:cb-scheme}.

\begin{figure}[h]
	\centering
  	\includegraphics[width=0.5\textwidth]{Connection_Bridge.png}
  	\caption{Esquema de la sincronización con \textit{Connection Bridge}}
  	\label{fig:cb-scheme}
\end{figure}

Esta manera de sincronizar los estados de los \textit{notebooks} depende íntegramente en el funcionamiento del \textit{Connection Bridge}. Éste debe actuar como \textit{proxy}, impidiendo que el \textit{kernel} original vea que está conectado a más de un \textit{notebook}. Además tiene que implementar \textit{The wire protocol} \cite{wire-protocol} tanto en su conexion con el \textit{notebook}, pues tiene que aparecer como un \textit{kernel}; como en su conexion con el \textit{kernel}, haciéndose pasar por un cliente. 

Con este modelo, la versión del \textit{notebook} que se está modificando, es decir, la del usuario con permisos de edición, será la que se persista en disco. Esa versión es la original, y no se puede asegurar que las instancias de los espectadores sean consistentes con ella. Si todos los mensajes se han mandado y recibido bien y el \textit{Connection Bridge} ha funcionado sin errores, los dos \textit{notebooks} deberían ser idénticos, pero en cuanto se produzca un error no se podrá estar seguro de ello.

Por otro lado, se plantea otra manera de realizar la sincronización, esta vez sin hacer uso de componentes externos. Este nuevo modelo se basa en programar que, tanto el \textit{notebook} que se está modificando como aquellos que se estén editando, se guarden o carguen con una frecuencia concreta desde disco. El hecho de realizar la sincronización de esta manera ofrece la ventaja de no tenerse que preocupar por las inconsistencias que podían surgir con la utilización del \textit{Connection Bridge}. Al cargar el archivo desde el disco, se tiene la certeza de que va a ser consistente. Se puede ver el esquema de este modelo en la Figura \ref{fig:disk-scheme}.

\begin{figure}[h]
	\centering
  	\includegraphics[width=0.5\textwidth]{JSON-sync.png}
  	\caption{Esquema de la sincronización con carga desde disco}
  	\label{fig:disk-scheme}
\end{figure}


\subsection{Autenticación, autorización e identificación}
\label{subsec:identificacin-permisos}

En cuanto a la identificación, se necesita un nombre público para que los usuarios se reconozcan entre sí. Internamente, cada usuario tendrá asignado un identificador único y se guardará una \textit{\gls{cookie}} en el navegador durante cada sesión, para no tener que identificarlo en cada petición. No se ha planteado ninguna otra solución para el problema de la identificación.

Por otro lado, para los permisos si que se han planteado diversos modelos, desde algunos con grandes libertades para todos los usuarios y basados en la confianza hasta modelos bastante restrictivos donde la autorización para realizar las acciones está muy medida.

El modelo que se va a utilizar es un sistema de roles, de manera que cada usuario tiene un rol en cada \textit{notebook} en el que participa. Existen cuatro roles en el sistema planteado, los cuales se van a explicar brevemente.

\begin{itemize}

\item \textbf{Administrador}: Se encarga de gestionar el \textit{notebook}, pero no lo puede modificar. Es el encargado de invitar a otros usuarios a formar parte del documento, así como de renombrarlo o eliminarlo. También es el que controla quién modifica el \textit{notebook}, puediendo cambiar los roles del resto de usuarios. 

\item \textbf{Editor}: Es el rol que puede modificar y ejecutar los contenidos del notebook. No puede realizar ninguna función de administración.

\item \textbf{Administrador-editor}: Se trata del rol con más permisos. Es la combinación de los roles de Administrador y Editor, pudiendo llevar a cabo todas las funciones de cada uno de éstos.

\item \textbf{Espectador}: Es el rol más restrictivo. Tan solo puede acceder al documento y ver los cambios que se realizan. No puede ni modificar ni administrar.

\end{itemize}

En la solución final elegida, sólo puede haber un administrador y un editor a la vez en cada \textit{notebook}. Por lo tanto, las dos situaciones posibles son: un Administrador-editor y \textit{N} espectadores o bien un Administrador, un Editor y \textit{N} espectadores. Los detalles de la gestión de roles se especificarán en el capítulo \ref{ch:diseno-solu}.

Por último, para la autenticación se disponía de un gran abanico de opciones, desde algunas poco robustas, como mantener la contraseña de servidor que implementa \textit{Jupyter} hasta otras como crear nuestro propio sistema de autenticación.

Se planteó hacer uso del sistema clásico de autenticación mediante usuario y contraseña, almacenando la contraseña \textit{\gls{hash}eada} en la base de datos. Este modelo es suficientemente robusto para el sistema a desarrollar, y puede ser una buena opción para solucionar el problema de la seguridad.

Por otro lado, se valoró hacer uso de una autenticación mediante terceros, haciendo uso de la tecnología \textit{OAuth} \footnote{https://oauth.net/}. Esta opción permite autenticar al usuario a través de otras plataformas, lo cual es una ventaja, pues no tienen que crear una cuenta explícitamente para nuestra aplicación. Estas plataformas facilitarán la información necesaria para identificar al usuario en nuestra aplicación.


\subsection{Gestión de \textit{notebooks}}
\label{subsec:comparticion}

En lo que concierne a la gestión de los \textit{notebooks}, se discutieron varias soluciones. Al igual que con la autorización, se puede optar por sistemas más o menos restrictivos a la hora de compartir los \textit{notebooks}, desde que todos los usuarios puedan acceder a todos los documentos hasta que tengan que ser invitados para acceder a cada uno de ellos, tal y como se indica en la crítica al estado del arte, sección \ref{sec:critica-estado}.

Esta última opción ha sido la elegida para el proyecto a desarrollar, pues se quiere poder mantener una privacidad dentro de la plataforma, y que solamente accedan a los documentos aquellos usuarios que han sido autorizados a ello.

Para acceder a un documento, un usuario tiene que ser invitado por un administrador, en este caso entrará como espectador al documento en cuestión; o bien puede crear un documento nuevo, en el cuál será el único usuario, y, por tanto, el Administrador-editor.


\subsection{Persistencia}
\label{subsec:persistencia}

Para la persistencia, desde el principio se planteó hacer uso de una base de datos, donde se almacenarán los usuarios, sus roles y notebooks en los que participan. Sus cararcterísticas y diseño serán mostradas en el capítulo \ref{ch:diseno-solu}, junto con más información sobre este componente.


% SOLUCIÓN PROPUESTA

\section{Solución propuesta}
\label{sec:solucion-propuesta}

En la sección anterior se han detallado las posibles soluciones para cada uno de los problemas planteados. En este punto se comentarán cuáles han sido los elegidos para llevar a cabo en el desarrollo del proyecto.

\begin{itemize}

\item \textbf{Sincronización}: Se ha optado por el sistema de sincronización de guardado y cargado de archivos desde disco. Se puede ver su esquema en la figura \ref{fig:disk-scheme}. 

\item \textbf{Autenticación, autorización e identificación}: Se ha elegido un sistema de identificación mediante un nombre de usuario público, un sistema de autorización que asigna un rol por usuario para cada \textit{notebook} y un sistema de autenticación basado en terceros, haciendo uso de la tecnología \textit{OAuth}.

\item \textbf{Gestión de \textit{notebooks}}: Se utiliza un sistema de invitaciones, mediante el cuál el Administrador de un documento puede invitar a otros usuarios para que formen también parte de él.

\item \textbf{Persistencia}: Se va a hacer uso de una base de datos para almacenar la infomación que se quiere persistir.

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                             DISEÑO DE LA SOLUCIÓN                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Diseño de la solución}
\label{ch:diseno-solu}

Tomando como punto de partida las diferentes soluciones elegidas en el capítulo anterior, se ha llevado a cabo su diseño. Este diseño de los diferentes componentes que formarán la aplicación final pasa por dos fases. La primera será un diseño general, entender el sistema como un todo y viendo qué papel desempeña cada uno de los componentes dentro de éste. Se tratará este asunto en la sección \ref{sec:arquitectura-sistema} \textit{Arquitectura del sistema}. Por otro lado, habrá que profundizar en cada uno de estos componentes, haciendo un estudio específico y detallado de todos ellos, aspectos que veremos en la sección \ref{sec:diseno-detallado} \textit{Diseño detallado}. Para finalizar el capítulo, se hablará de las tecnologías utilizadas a lo largo de todo el proyecto, más concretamente en cada uno de los componentes.


% ARQUITECTURA DEL SISTEMA

\section{Arquitectura del sistema}
\label{sec:arquitectura-sistema}

\begin{figure}[h]
	\centering
  	\includegraphics[width=1\textwidth]{Architecture.png}
  	\caption{Esquema general de la arquitectura del sistema}
  	\label{fig:general-arch}
\end{figure}

La arquitectura del sistema toma como base la arquitectura propia de \textit{Jupyter}, dónde la pieza principal, que sirve como nexo de unión es el servidor de \textit{notebooks}. A esta pieza se conectaban, originalmente, y como muestra la Figura \ref{fig:components}: el navegador, los \textit{notebooks} (tanto para su carga y guardado en disco como para el hecho de mantenerlos en memoria una vez estaban abiertos) y por último, los \textit{kernels}.

Aparte de todos estos componentes ya nombrados, que se mantienen en el sistema final, pues se encargan de las funcionalidades indispensables de Jupyter, se van a añadir dos componentes más, que van a ser la base de datos y el sistema de autenticación. Se puede ver un esquema de la arquitectura final del sistema en la Figura \ref{fig:general-arch}.

En cuanto a las conexiones, se mantienen los protocolos utilizados originalmente, como eran \textit{HTTP} entre el navegador y el Servidor de \textit{notebooks} y \textit{ZeroMQ} entre entre el Servidor de \textit{notebooks} y el \textit{kernel}. 

Para los componentes nuevos, se utiliza \textit{HTTP} en ambos casos. En primer lugar, la base de datos funciona como un servicio aparte del Servidor de \textit{notebooks}. Esto quiere decir que se desplega de forma independiente, y que para acceder a los datos, el servidor de \textit{notebooks} tendrá que hacer una petición al servidor de la base de datos. Este último hará la consulta especificada y devolverá la información pertinente. Por otro lado, de la autenticación se encarga la plataforma \textit{Auth0} \footnote{https://auth0.com/}, la cual funciona como una herramienta de \textit{Authentication as a service}, y que se detallará en más profundidad en la próxima sección. La conexión entre el servidor de \textit{notebooks} y \textit{Auth0} funciona mediante redirecciones. El usuario que se tiene que autenticar es redireccionado a una \textit{URL} dentro del dominio de \textit{auth0}, y, una vez autenticado, es devuelto al servidor de \textit{notebooks}, dónde se ha enviado ya su información para poder ser identificado. 

Los diferentes procesos se han marcado con líneas discontinuas en la figura \ref{fig:general-arch}. Se puede ver como el acceso a memoria y a disco forman parte del proceso del servidor de \textit{notebooks}, así como el acceso a la base de datos forma parte del proceso del servidor de la base de datos. El resto de componentes tienen su proceso independiente.


% DISEÑO DETALLADO

\section{Diseño detallado}
\label{sec:diseno-detallado}

Una vez vista la arquitectura a nivel general que tendrá la plataforma, se pasa a ver cómo estan diseñados a nivel interno cada uno de los componentes previamente mostrados. Se explicará  el diseño la base de datos y el sistema de autenticación, ya que, a nivel de diseño, el resto de componentes se mantienen prácticamente iguales a como lo eran en el \textit{Jupyter} original. Del funcionamiento de la herramienta resultante del proyecto desarrollado se hablará en el capítulo \ref{ch:desarrollo-solucion} \textit{Desarrollo de la solución propuesta}.


\subsection{Base de datos}
\label{subsec:diseno-bd}

Tal y como se ha explicado en el apartado anterior, la base de datos funciona como un proceso externo al servidor de \textit{notebooks}. Ésto quiere decir que para poder acceder a ella hay que lanzar el servicio. De esta manera el servidor de notebooks puede hacer peticiones al servidor de la base de datos, el cual se encargará de realizar las consultas y devolver la información que ha sido solicitada. 

Desde el punto de vista del diseño de la arquitectura, se podría haber eliminado el servidor de la base de datos, haciendo que fuera directamente el servidor de \textit{notebooks} el que realizara las consultas. La ventaja de desacoplar el componente es que se puede acceder a la base de datos sin necesidad de hacerlo desde el servidor de \textit{notebooks}, es decir, se puede hacer uso de la base de datos desde fuera de \textit{Jupyter}, o tener más de una aplicación haciendo peticiones simultáneamente. 

Su implementación es bastante sencilla, haciendo uso de la herramienta \textit{Tornado}  \footnote{http://www.tornadoweb.org/en/stable/} para gestionar los \textit{handlers} que se encargan de las peticiones. Por otro lado se utiliza \textit{SQLite}\footnote{https://www.sqlite.org/index.html} , que es el motor de la base de datos y la herramienta desde la cual se accede, consulta y modifica. 

En lo que respecta a la organización de la información en la base de datos, se puede ver un esquema de las tablas y columnas en la Figura \ref{fig:db-scheme}. 

\begin{figure}[h]
	\centering
  	\includegraphics[width=0.75\textwidth]{database.png}
  	\caption{Esquema de tablas de la base de datos}
  	\label{fig:db-scheme}
\end{figure}

La base de datos está compuesta por dos tablas. En primer lugar la tabla \textit{Users}, donde se puede encontrar la información acerca de los usuarios registrados en la plataforma. Se compone de las siguientes columnas:

\begin{itemize}

\item \textbf{auth\_id:} Identificador único para cada usuario, es enviado por \textit{auth0} cuando el usuario se autentica. También constituye la clave primaria de la tabla.

\item \textbf{cookie:} Se guarda la \textit{cookie} que genera \textit{Jupyter} para identificar la sesión del usuario. Se actualizará al cambiar de sesión.

\item \textbf{jwt:} \textit{JSON Web Token} \footnote{https://jwt.io/} , es enviado por \textit{auth0} al realizar la autenticación, y contiene información sobre el usuario. Se almacena encriptado.

\item \textbf{nickname:} Nombre de usuario que se mostrará en la plataforma. Es enviado por \textit{auth0} en base al proveedor de identidad que se escoja.

\item \textbf{expire:} Momento en el que expira el \textit{\gls{JWT}} generado por \textit{auth0}. El usuario se tendrá que autenticar de nuevo pasada esta fecha.

\end{itemize}

En segundo lugar, se encuentra la tabla \textit{notebooks}, que muestra la información acerca de todos los archivos \textit{notebook} registrados en el servidor. Está compuesta por las colunas siguientes:

\begin{itemize}

\item \textbf{auth\_id:} Es el mismo dato que en la tabla Users. Sirve como punto para relacionar las dos tablas. 

\item \textbf{role:} Rol asignado, puede ser uno de estos cuatro valores: Administrador-editor, Administrador, Editor o Espectador.

\item \textbf{notebook:} Nombre del \textit{notebook} que se referencia. En caso de no encontrarse en el directorio \textit{root}, se mostrará la ruta para acceder a él.

\end{itemize}


\subsection{Sistema de autenticación}
\label{subsec:diseno-auth}

Para llevar a cabo el sistema de autenticación se ha hecho uso de la plataforma \textit{auth0}, como se ha introducido previamente en la sección \ref{sec:arquitectura-sistema} \textit{Arquitectura del sistema}. A continuación se introducirá y explicará su funcionamiento.

\textit{Auth0} es una plataforma de \textit{Authentication as a Service}. Sirve para autenticar a usuarios sin necesidad de implementar un sistema propio, simplemente delegando esta tarea en ella. Para conectar la aplicación con \textit{auth0} se tienen que programar una serie de redirecciones. Cuando aparece un usuario en el sistema que no está identificado se le redirige a una dirección dentro del dominio de \textit{auth0}. Esta \textit{URL} está asociada a la aplicación, de esta manera \textit{auth0} sabe que va a a autenticar al usuario para esta plataforma en concreto. Una vez aquí, el usuario tendrá diversas opciones para realizar el \textit{login}. Estas opciones se pueden seleccionar en la configuración de la aplicación en el menú de \textit{auth0}, y más adelante se explicará cuáles se han elegido. Una vez autenticado el usuario, se le devolverá de nuevo a la aplicación, donde ya podrá funcionar con normalidad y acceder a sus documentos.

\begin{figure}[h]
	\centering
  	\includegraphics[width=0.9\textwidth]{auth0-flow.png}
  	\caption{Flujo de autenticación mediante \textit{auth0}, usando \textit{OAuth}}
  	\label{fig:auth0-scheme}
\end{figure}

La comunicación interna para que esto sea posible se puede ver en la Figura \ref{fig:auth0-scheme}. El proceso es el siguiente: 

El navegador se redirige a \textit{Auth0} para que el usuario se autentique (\textit{Paso 1}). \textit{Auth0} entonces solicita una autenticación al proveedor de identidad (\textit{Paso 2}). Después de verificar al usuario, pidiéndole que haga \textit{login} (\textit{Paso 3}), el proveedor de identidad le devuelve un código a a la \textit{URL} de \textit{\gls{callback}} de \textit{Auth0} (\textit{Paso 4}). Al recibir el código, \textit{Auth0} lo cambiará por un \textit{token} de acceso haciendo una petición \textit{POST} a la \textit{URL} de \textit{token} del proveedor de identidad (\textit{paso 5}) y recibirá el \textit{token} de acceso en la \textit{URL} de \textit{callback} (\textit{paso 6}). Más tarde, otra secuencia de intercambio de \textit{tokens} sucederá entre \textit{Auth0} y el servidor de \textit{notebooks}, donde \textit{Auth0} mandará un código al servidor de \textit{notebooks} (\textit{paso 7}) y el servidor cambiará el código por el \textit{token} de identificación (\textit{pasos 8 y 9}).

Este token de identificación será el que se utilice en la plataforma a desarrollar. Se trata de un \textit{JWT} que contiene la información sobre el usuario. Los \textit{tokens JWT} están compuestos por tres partes: Una cabezera (\textit{header}) donde aparece el algoritmo de encriptado; el contenido (\textit{payload}), de donde extraeremos la información que se ha solicitado sobre el usuario en cuestión y, por último, una firma (\textit{signature}), que se realiza utilizando la clave privada de aquél que envia el token, para verificar que proviene de donde dice provenir\footnote{https://jwt.io/introduction/}.

Una vez desencriptado el token, se puede acceder a su contenido, y recuperar aquella información que sea útil conocer para nuestra plataforma. Concretamente, interesa recuperar la siguiente información, que ya se ha introducido en la subsección anterior cuando se hablaba de la tabla \textit{Users} en la base de datos:

\begin{itemize}

\item \textbf{\textit{JWT}}: Se guarda el \textit{JWT}, ya que puede ser de utilidad más adelante porque contiene toda la información. Corresponderá a la columna \textit{jwt} en la base de datos.

\item \textbf{sub}: Es el identificador único del usuario. Tiene el formato (proveedor de identidad)|(id único dentro del proveedor). Un ejemplo sería \textit{github|1234567890}. Corresponderá a la columna \textit{auth\_id} en la base de datos.

\item \textbf{name}: Nombre de usuario que devuelve el proveedor de identidad. Corresponderá a la columna \textit{nickname} en la base de datos.

\item \textbf{exp}: Fecha en la que deja de ser válido el \textit{JWT}. Corresponderá a la columna \textit{expire} en la base de datos.

\end{itemize}

El diagrama de flujo que se ve en la Figura \ref{fig:auth0-scheme} corresponde a la secuencia de acciones llevadas a cabo en el caso de que el usuario se identifique con la aplicación de un tercero (el proveedor de identidad). \textit{Auth0} permite la identificación de esta manera mediante muchas plataformas, como es el caso de \textit{Google}, \textit{Github}, \textit{Linkedin}, etc \footnote{https://auth0.com/docs/connections}. Sin embargo, también ofrece la posibilidad de utilizar al propio \textit{Auth0} como proveedor de identidad. En este caso, el usuario se registra con un correo y contraseña, así como el \textit{nickname} que quiera, para ser identificado por el resto de usuarios dentro de la plataforma. De esta manera, no se necesita llamar a un tercero, los pasos 2, 4, 5 y 6 vistos en el diagrama de la figura \ref{fig:auth0-scheme} se omitirían, y del paso 3 se encargaría el propio \textit{Auth0}. El esquema resultante sería el de la Figura \ref{fig:auth0-scheme-2}.  

\begin{figure}[h]
	\centering
  	\includegraphics[width=0.75\textwidth]{auth0-flow2.png}
  	\caption{Flujo de autenticación mediante \textit{auth0} sin proveedor de identidad externo}
  	\label{fig:auth0-scheme-2}
\end{figure}

Para el sistema a desarrollar se ha optado por ofrecer tanto la autenticación por terceros utilizando \textit{OAuth} así como la posibilidad de entrar en la plataforma mediante un correo electrónico y contraseña, que será guardado directamente en el dominio de \textit{auth0}. En la figura \ref{fig:login} se puede ver la interfaz del \textit{login} de \textit{auth0} para nuestra plataforma, donde se muestran las dos opciones previamente comentadas.

\begin{figure}[H]
	\centering
  	\includegraphics[width=0.5\textwidth]{login.png}
  	\caption{Interfaz de \textit{login} de \textit{auth0}}
  	\label{fig:login}
\end{figure}


% TECNOLOGÍA UTILIZADA

\section{Tecnología utilizada}
\label{sec:tecno-utilizada}

Se ha utilizado diversas herramientas y tecnologías a lo largo del desarrollo del proyecto. se han ido introduciendo muchas de ellas en el transcurso de la memoria, en los puntos en los que resultaba relevante mencionarlas. Por lo tanto, esta sección servirá como un pequeño glosario donde se pueden encontrar todas las herramientas utilizadas sin entrar en grandes detalles sobre su funcionamiento. Estará estructurada por componentes, los vistos en la Figura \ref{fig:general-arch}, siendo cada uno una subsección de este punto.


\subsection{Servidor de \textit{notebooks}}
\label{subsec:tecno-server}

El servidor de notebooks utiliza una gran variedad de tecnologías. El \textit{backend} está programado en \textit{Python}, haciendo uso de \textit{Tornado} para implementar los \textit{handlers} del servicio \textit{web}. En cuanto al \textit{frontend}, hace uso de \textit{JavaScript} \footnote{https://www.javascript.com/} y de \textit{HTML} \footnote{https://es.wikipedia.org/wiki/HTML}. Los archivos \textit{notebook} que se encuentran en el servidor, ya sea en disco o en memoria, son documentos \textit{JSON}, así que se hace uso de esta tecnología para la persistencia de la información. Por último, las conexiones con el resto de componentes se realizan en casi todos los casos por \textit{HTTP}, siendo el \textit{kernel} una excepción, pues hace uso de \textit{ZeroMQ}. 


\subsection{\textit{Kernels}}
\label{subsec:tecno-kernels}

Como se ha comentado anteriormente, los \textit{kernels} hacen uso de \textit{ZeroMQ} para el intercambio de información mediante mensajería, tal y como está especificado en \textit{The wire protocol} \cite{wire-protocol}. No se ha desarrollado ningún \textit{kernel} para este trabajo, pero normalmente se programan en el lenguaje que implementan. Más información en la subsección \ref{subsec:estructura-kernel}.


\subsection{Base de datos}
\label{subsec:tecno-DB}

La base de datos utiliza la herramienta \textit{SQLite} para su gestión. Se ha hecho uso de esta plataforma porque se necesitaba una solución ligera y robusta, por lo que era una gran opción. En cuanto al servidor de la base de datos, está programado en \textit{Python}, haciendo uso de la plataforma \textit{Tornado} para los servicios \textit{web} y se comunica por \textit{HTTP} con el servidor de \textit{notebooks}.


\subsection{Sistema de autenticación}
\label{subsec:tecno-auth}

Tal y como se ha expuesto en la subsección \ref{subsec:diseno-auth}, de la autenticación se encarga la herramienta \textit{Auth0}. \textit{Auth0} posibilita el uso de múltiples modos de autenticación, integrándolos en un servicio basado en \textit{tokens} \textit{JWT}. Dentro de sus tecnologías disponibles se encuentra \textit{OAuth}, para identificar al usuario mediante proveedores de identidad externos. También se ofrece la posibilidad de crear una cuenta en \textit{Auth0} y que sea la propia plataforma la que autentique al usuario. Estas dos opciones son las elegidas y contempladas en la aplicación.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                   DESARROLLO DE LA SOLUCIÓN PROPUESTA                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Desarrollo de la solución propuesta}
\label{ch:desarrollo-solucion}

Una vez finalizado el diseño, se procede a la implementación de cada una de las partes o componentes especificados. Se trabaja de una manera escalonada durante el desarrollo del proyecto. En primer lugar se plantean los objetivos a cumplir, y tomando como base estos objetivos, se atacan uno por uno. Por lo tanto, se analiza el objetivo, se diseña su solución en concreto, se implementa y se prueba. En el momento en que el objetivo queda solucionado, se avanza al siguiente.

Se tomó como base para la implementación el repositorio de \textit{Github} de \textit{Jupyter notebook}, más concretamente su versión estable 5.5.0 \footnote{https://github.com/jupyter/notebook/releases/tag/5.5.0}. Debido al gran tamaño del repositorio, fué bastante costoso familiarizarse con él y descubrir qué archivos realizaban qué funciones. Además, hubo que aprender a utilizar las tecnologías que se empleaban en el repositorio, como por ejemplo \textit{Tornado}.

A continuación se expondrá, por orden de realización, cuál fué el proceso de desarrollo de cada uno de los objetivos.


% SINCRONIZACIÓN DE NOTEBOOKS EN TIEMPO REAL

\section{Sincronización de \textit{notebooks} en tiempo real}
\label{sec:desarrollo-sincro}

Se comenzó a realizar la implementación de la solución por este objetivo. A lo largo de todo el desarrollo y programación de las soluciones, se intentará reutilizar al máximo aquellos fragmentos de código de la plataforma original que nos puedan resultar útiles. Este es el caso de la sincronización, pues \textit{Jupyter} realiza un guardado automático en disco siguiendo un intervalo, y, al abrir un \textit{notebook} carga sus contenidos desde disco.

Una vez identificados estos dos métodos, se procede a crear un intervalo en el que se llamará, según el rol del usuario en el \textit{notebook} a un método o a otro, para que la instancia que ve ese usuario sea la que se cargue o se guarde (todavía no estaba implementado el sistema de roles pero ya estaba diseñado). Se fijó el tiempo del intervalo para la carga y guardado en un segundo, pues es un tiempo de espera razonable, y, en caso de ser menor, el consumo de recursos se dispara, llegando a un punto insostenible, véase la Figura \ref{fig:load-compare}.

Surgió un problema con la carga de \textit{notebooks}, porque el método que la realiza rompe el contenedor \textit{web} de la interfaz sobre el que van insertadas todas las celdas del documento, y, cuando se van a insertar las nuevas celdas que se tienen que cargar, se crea otro contenedor, forzando a la ventana a hacer un \textit{\gls{scroll}} hasta arriba del todo. Ésto supone un problema para el usuario que está espectando los cambios en el \textit{notebook}, pues no puede seguir el desarrollo que se produce, ya que cada segundo se le cambia la vista, llevándolo a la parte superior del archivo. Se solucionó este problema mediante la modificación del método de cargado, haciendo que no se rompiera el contenedor, y que se eliminaran y cargaran las celdas una por una. De esta manera, al realizar el cargado, el usuario se mantiene en lugar en el que se encontraba previamente, haciendo que no pierda la vista en la que se encontraba.


% CREACIÓN DE UN SISTEMA DE ROLES Y PERMISOS

\section{Creación de un sistema de roles y permisos}
\label{sec:desarrollo-roles}

El desarrollo del sistema de roles depende en gran medida de la base de datos. El sistema de roles hace muchas consultas para conocer el rol de cada usuario en cada momento, así como para realizar modificaciones en el caso de que sea necesario. 

Los roles se deben tener en cuenta en la aplicación principalmente en dos sitios. En primer lugar, en el ciclo de ejecución de los \textit{notebooks}. Como se ha comentado en la sección \ref{sec:desarrollo-sincro} sobre la sincronización, se hace uso de un intervalo para el guardado y la carga de los archivos. En este punto se tiene que comprobar el rol de cada usuario, para saber si cargará o guardará el archivo, así como actualizar un \textit{\gls{flag}} creado en la interfaz para que el usuario sepa qué rol tiene. En el caso de que el usuario tenga permisos de administración se le mostrará en un submenú sus acciones disponibles, como se aprecia en la Figura \ref{fig:detalle-nb}. Por otro lado, es importante conocer el rol para saber si un usuario tiene potestad para realizar ciertas acciones sobre un notebook, como por ejemplo renombrarlo o eliminarlo. En estos casos, en el propio \textit{handler} de la petición, se pedirá a la base de datos que compruebe el rol del usuario, en el caso de no tener los permisos necesarios para realizarla, se enviará el código de estado \textit{HTTP} 401, usuario no autorizado. 

\begin{figure}[H]
	\centering
  	\includegraphics[width=1\textwidth]{detalle-nb.png}
  	\caption{Detalle sobre los permisos del administrador}
  	\label{fig:detalle-nb}
\end{figure}

El usuario encargado de la administración de un \textit{notebook} puede delegar los permisos de modificación en otro usuario. Para ello, aparece el submenú \textit{Collaborator} en el menú \textit{File} en la interfaz. El submenú es un desplegable donde se muestran todos los usuarios que forman parte del \textit{notebook}. Este desplegable se consigue pidiéndole la información a la base de datos, e insertando cada uno de los usuarios devueltos en el código \textit{HTML} por medio de \textit{\gls{jquery}}\footnote{https://jquery.com/}. Cuando se hace \textit{click} en un usuario, se manda una petición a la base de datos para convertirlo en editor. Se pueden dar los siguientes casos en función del rol del usuario seleccionado:

\begin{itemize}

\item \textbf{Administrador-editor o Editor}. Todo se mantiene tal y como está, pues el usuario ya tiene premisos de edición, no hay que modificar nada.

\item \textbf{Administrador}. Si el usuario elegido es administrador quiere decir que existe un usuario con el rol de Editor. El Administrador pasa a Administrador-editor y el Editor pasa a Espectador.

\item \textbf{Espectador}. Si se trata de un Espectador, se pueden dar dos casos. En primer lugar, que exista un Editor, por lo que éste pasaría a Espectador y el Espectador elegido a Editor. Por otro lado, si no existe un Editor, tiene que existir un Administrador-editor, por lo que éste pasaría a ser Administrador y el Espectador sería el nuevo Editor.

\end{itemize}

El sistema de roles no puede funcionar sin la capa de persistencia, porque se perdería toda la información cuando el servicio se cayera y se volviera a lanzar, ya que no se podría recordar qué usuario tiene qué rol en qué \textit{notebook}.


% PERSISTENCIA DE LA INFORMACIÓN NECESARIA

\section{Persistencia de la información necesaria}
\label{sec:desarrollo-persistencia}

La persistencia se llevó a cabo mediante una base de datos, cuyo diseño se ha introducido en la subsección \ref{subsec:diseno-bd}. Para su desarrollo se utilizó la herramienta \textit{SQLite}. Ésta permitió realizar una implementación sencilla y robusta. 

En un primer momento, la base de datos se accedía directamente desde el servidor de \textit{notebooks}, habiendo importado la herramienta \textit{SQLite} en este componente y realizando las llamadas en los lugares adecuados. \textit{SQLite} trabaja con código \textit{SQL} \footnote{https://es.wikipedia.org/wiki/SQL} , un lenguaje sumamente extendido,  por lo que no fué complicado programar todas las consultas necesarias para el correcto funcionamiento de la plataforma, ya que la base de datos es muy pequeña (véase la Figura \ref{fig:db-scheme}) y las consultas que se requieren son sencillas.

Más tarde, se optó por cambiar el acceso a la base de datos e implementarlo como un servicio \textit{web} externo. Este cambio no supuso ningún problema a nivel de programación, y se procedió de la siguiente manera. En primer lugar se colocaron los métodos de acceso a la base de datos en un archivo \textit{Python} nuevo. Entonces, se metió cada método dentro de un \textit{handler} de una petición \textit{HTTP}. Ésto se llevó a cabo haciendo uso de la plataforma \textit{Tornado}, pues ya se conocía debido a su uso en el servidor de \textit{notebooks}. Más tarde, se cambiaron los puntos donde originalmente se hacían los accesos en el servidor de \textit{notebooks} por peticiones \textit{HTTP} al servidor de la base de datos. Por último, los datos que se solicitan en las peticiones se devuelven en las respuestas \textit{HTTP}, y son gestionados de forma asíncrona por el servidor de \textit{notebooks}.


% SESIONES DE LOS USUARIOS

\section{Sesiones de los usuarios}
\label{sec:desarrollo-sesiones}

Mantener las sesiones de los usuarios es necesario para que no se pierda el flujo de trabajo en el caso de que, por ejemplo, se actualice la página o se cierre el navegador. En un principio, se crearon unas \textit{cookies} que se guardaban en la base de datos e identificaban al usuario. Estas \textit{cookies} se creaban de cero,  caducaban al cabo de un tiempo, y se utilizaban para saber qué usuario estaba conectado en el navegador, manteniendo su sesión. 

Como un usuario puede conectarse a la plataforma desde otros ordenadores o navegadores, con este sistema se perdían sus datos, pues lo único que lo identificaba era la propia \textit{cookie}. Al cambiar de sistema de seguridad, y utilizar una plataforma externa como \textit{Auth0}, la \textit{cookie} pasó a tener la utilidad que debe tener, es decir, mantener la sesión. Se eliminó la implementación de la \textit{cookie} personalizada y pasó a utilizarse una creada por \textit{Jupyter} originalmente. Ésta se genera y guarda en la base de datos cuando un usuario se autentica. En el momento en el que el usuario se conecta desde otro navegador o ordenador, se actualiza la \textit{cookie} en la base de datos, haciendo que cualquier otra \textit{cookie} asociada al usuario en otro navegador quede invalidada y resultando en que el usuario se tenga que volver a autenticar en ese navegador. Si la \textit{cookie} llega al punto de caducar, se exige la autenticación del usuario de nuevo.


% COMPARTICIÓN DE LOS DOCUMENTOS

\section{Compartición de los documentos}
\label{sec:desarrollo-comparticion}

Respecto a la compartición de los documentos, se ha desarrollado el siguiente sistema. Cuando un usuario entra por primera vez en la plataforma, depués de realizar el \textit{login} se encuentra con un directorio vacío, esto se debe a que no forma parte de ningún documento. El usuario tiene la opción de crear un documento, de esta manera se convertiría en el Administrador-editor de este \textit{notebook}, véase la subsección \ref{subsec:identificacin-permisos}. La otra opción de la que dispone es que el usuario con permisos de administración de otro documento le dé acceso. Para ello, el Administrador deberá seleccionarlo en el submenú \textit{Add user}, en el que aparecen todos los usuarios registrados en la plataforma que no pertenezcan ya al documento.

Este submenú funciona de manera similar al explicado en la sección \ref{sec:desarrollo-roles}, insertando por medio de \textit{jquery} los diferentes usuarios dados de alta en la plataforma (tras la pertinente consulta a la base de datos) en el \textit{HTML} que se mostrará. Cuando se elige un usuario, se realiza una petición al servidor de la base de datos para generar una entrada con este usuario como Espectador en el \textit{notebook} en cuestión.

A partir de este momento, se mostrará en el \textit{notebook} el directorio del usuario. Ésto se consigue haciendo una consulta a la base de datos para que devuelva la lista de \textit{notebooks} en la que aparece el usuario. Esta lista, más tarde se comparará con el contenido real del directorio, y se listarán solo los \textit{notebooks} que aparecen en ambos lados.


% AUTENTICACIÓN DE LOS USUARIOS

\section{Autenticación de los usuarios}
\label{sec:desarrollo-auth}

Tal y como se ha expuesto en la sección \ref{sec:desarrollo-sesiones}, la identificación de usuarios se realizaba en primera instancia mediante la \textit{cookie} generada en el servidor de \textit{notebooks}. Al no ser éste un método lo suficientemente robusto tanto para la seguridad de la plataforma como para el uso por parte de los usuarios, se decidió cambiar.

El nuevo sistema hace uso de la plataforma \textit{Auth0} para la autenticación de los usuarios. Para poner en marcha este sistema, se creó una cuenta en \textit{Auth0} y se registró la aplicación. De esta manera, se generan unas \textit{URLs} específicas de la aplicación a las que se tiene que redirigir al usuario para que realice su \textit{login}. También son generados el identificador de la aplicación así como una clave secreta. Por último hace falta especificar la dirección a la que se debe redirigir al usuario una vez termine su autenticación, llamada \textit{callback URL}. 

Por otro lado, en el servidor de \textit{notebooks} se realiza un \textit{bypass}, que consiste en redirigir a todos los usuarios no identificados en la plataforma a la \textit{URL} de \textit{login} de \textit{Auth0}. En esta \textit{URL} va incluido como argumento el identificador de nuestra aplicación. Una vez el usuario es autenticado, se devuelve el usuario a la \textit{callback URL} especificada en los ajustes de la aplicación de \textit{Auth0}. Se recibe un código, que habrá que mandar haciendo una petición tipo \textit{POST} por \textit{HTTPS} a una \textit{URL} de las generadas previamente junto con el identificador de la aplicación y la clave secreta. De esta manera, \textit{Auth0} sabe que se tienen permisos para generar los \textit{JWT}, así que se generan y se devuelven.
Se puede ver una vista detallada de esta interacción en el esquema de la Figura \ref{fig:auth0-scheme}, así como más información en la documentación de \textit{Auth0} \footnote{https://auth0.com/docs/application-auth/current/server-side-web}.

Con el \textit{JWT} correspondiente al \textit{login} del usuario en nuestro dominio, se procede a desencriptarlo, haciendo uso de la clave pública de nuestra aplicación, pues viene firmado con la privada para saber que es quién dice ser. Una vez desencriptado, se guardará la información relevante en la base de datos.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              IMPLANTACIÓN	                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Implantación}
\label{ch:implantacion}

Para hacer uso de la aplicación y llevar a cabo su despliegue, se deben seguir una serie de pasos, ya que hay que realizar las conexiones de forma correcta, pues si no los componentes no se podrán comunicar entre ellos.

En primer lugar, hay que crear una cuenta en la plataforma \textit{Auth0} y dar de alta la aplicación. De esta manera se conseguirá el conjunto de \textit{URLs} y claves necesarias para redirigir al usuario y que se pueda autenticar. También se tendrá que configurar la \textit{URL} de \textit{callback} dentro de \textit{Auth0}, para que la redirección  del usuario de vuelta a nuestra plataforma sea exitosa. Esta \textit{URL} deberá pertenecer al dominio en el que se ejecuta la aplicación, y hay que tener en cuenta que si se cambia, se tendrá que añadir la nueva dirección a \textit{Auth0}.

Una vez configurada toda la información en \textit{Auth0}, se utilizarán las \textit{URLs} y códigos generados en el servidor de \textit{notebooks}. Para ello, hay que modificar las llamadas que se hacen en la redirección del \textit{login}, introduciendo las claves y direcciones que nos proporciona \textit{Auth0}, como se ha explicado en la sección \ref{sec:desarrollo-auth}. Por otro lado, hay que ver dónde se va a lanzar el servidor de \textit{notebooks}, ya que se necesitará una dirección para que los usuarios se conecten a la plataforma.

Por último, habrá que conectar el servidor de \textit{notebooks} y la base de datos. Para ello se tiene que especificar la dirección en la que se lanza la base de datos en el servidor de \textit{notebooks}. La base de datos no inicia ninguna comunicación, por lo que no se tiene que configurar nada por su parte. 

Para poner en marcha el sistema, se ejecutarán el servidor de la base de datos y el servidor de \textit{notebooks}. El directorio que aparecerá como \textit{root} en el servidor de notebooks es aquel en el que se ejecuta la aplicación. Es necesario tener esto en cuenta, ya que si cae el servidor y se inicia desde otro punto los usuarios pueden confundirse o no saber llegar a sus archivos. \textit{Auth0} está siempre escuchando, por lo que no es necesario hacer nada explícitamente en cuanto a esta herramienta. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               PRUEBAS 		                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Pruebas}
\label{ch:pruebas}


% VALIDACIÓN DEL SISTEMA

\section{Validación del sistema}
\label{sec:validacion-sistema}

A la hora de realizar las comprobaciones sobre el funcionamiento del sistema se ha seguido una metodología empírica. Tal y como se comentó en el capítulo \ref{ch:desarrollo-solucion}, el desarrollo de la solución se ha ido realizando por componentes o módulos dentro del sistema. Dentro de cada etapa del desarrollo de la aplicación, es decir, dentro de la impementación de cada módulo, se ha ido probando el funcionamiento del módulo en cuestión.

Para las comprobaciones relativas a cada componente se plantean casos de prueba que cubran el mayor conjunto de casos reales posibles. Se realizan todos los \textit{tests} propuestos sobre el componente y se valora, según los resultados obtenidos, si el componente cumple con su funcionalidad de manera correcta. En el caso de no hacerlo, se revisa la implementación para detectar los errores y corregirlos.

Las pruebas han sido acumulativas a lo largo del desarrollo del proyecto, por lo que, al probar un módulo y comprobar que éste funciona correctamente, hay que ver que ninguno de los implementados anteriormente haya dejado de funcionar. En el caso de que alguno dejara de funcionar habría que resolver los conflictos entre los dos componentes.

Una vez completada la implementación del proyecto se han realizado pruebas a nivel global para asegurarse de que el sistema cumple con todos los objetivos correctamente. Estas pruebas se han llevado a cabo como casos de uso, simulando las interacciones que se podrían realizar en la plataforma en un entorno real.


% PRUEBAS DE CARGA

\section{Pruebas de carga}
\label{sec:pruebas de carga}

Se ha realizado un estudio de la velocidad de refresco de los documentos en base a su tamaño. El intervalo de refresco predeterminado de los \textit{notebooks} es de un segundo, como se explica en la sección \ref{sec:desarrollo-sincro}. Este intervalo es la frecuencia con que los \textit{notebooks} se guardan, en el caso del usuario con permisos de edición, y se cargan, en el resto de casos. Esta frecuencia se reflejará de una forma fiel siempre que se pueda realizar la computación en un tiempo menor o igual al programado. Si se tarda más en guardar o cargar el notebook nunca se podrá cumplir este tiempo especificado.

Para comprobar en que punto se sobrecarga el sistema, se ha utilizado un \textit{notebook} compartido. Todas las celdas de este documento tenían tan solo una línea de código escrita. Por tanto, como las medidas se realizan por celdas, este sería el tiempo mínimo a obtener, ya que más líneas implicarían más información y más tiempo de refresco. 

Las pruebas se han realizado en un equipo con un procesador \textit{Intel Core i7-4790} y 16 \textit{GB} de memoria \textit{RAM}. El sistema operativo ha sido \textit{Ubuntu} en su versión 16.04 y el navegador \textit{Mozilla Firefox} en su versión 60.0.2.

\begin{figure}[h]
	\centering
  	\includegraphics[width=0.8\textwidth]{loadplot.png}
  	\caption{Gráfico de relación del número de celdas y tiempo de cargado de un \textit{notebook} con un intervalo de 1 segundo}
  	\label{fig:loadplot}
\end{figure}

En la figura \ref{fig:loadplot} se pueden ver los resultados obtenidos en esta prueba de carga. En el eje X se muestra el número de celdas del notebook y en el Y los segundos que ha tardado en verse reflejado el cambio. Se han realizado tres mediciones para cada \textit{notebook}, reflejadas con las cruces azules, y se ha obtenido la media, que se muestra con la línea roja.

Se puede apreciar que mientras el \textit{notebook} tiene menos de cien celdas se mantiene un intervalo de carga razonable, muy cercano a los dos segundos programados. En cuanto se supera este valor, el tiempo de refresco crece exponencialmente, tardando alrededor de diez segundos con doscientas celdas, treintaicinco con quinientas celdas y hasta cien con mil celdas. Se puede determinar que es este punto en el que el sistema se satura, haciendo que trabajar con \textit{notebooks} de estas dimensiones no resulte una experiencia tan fluida.

En la figura \ref{fig:load-compare} se realiza una comparativa del tiempo de carga de los \textit{notebooks} respecto al numero de casillas y el intervalo de refresco seleccionado. Cabe destacar que en esta figura, a diferencia de la \ref{fig:loadplot}, se utiliza una escala logarítmica en el eje \textit{Y}, lo que hace que las curvas no sean tan pronunciadas. Se puede ver como más o menos todos los valores se mantienen estables y cerca del intervalo seleccionado hasta las 50 celdas. En este punto empiezan a crecer, llegando todos a un tiempo de carga similar con 200 casillas. Después el intervalo de 0.5 segundos se dispara, mientras que los otros tres siguen un desarrollo similar entre ellos.

Se ha elegido el intervalo de un segundo porque, aunque no sea práctica habitual el uso de notebooks con más de 100 celdas\footnote{https://blog.jupyter.org/we-analyzed-1-million-jupyter-notebooks-now-you-can-too-guest-post-8116a964b536}, en el caso de llegar a esa cantidad, un intervalo menor añadiría demasiado tiempo de espera. En el caso de no llegar a un numero tan elevado, tan solo estamos perdiendo al rededor de medio segundo en los refrescos, lo cual es un coste asumible.

\begin{figure}[H]
	\centering
  	\includegraphics[width=0.8\textwidth]{all.png}
  	\caption{Comparativa de tiempo de cargado de \textit{notebooks} respecto al numero de celdas y frecuencia de refresco}
  	\label{fig:load-compare}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              CONCLUSIONES                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Conclusiones}
\label{ch:conclusiones}

Para concluir la memoria, se van a recuperar los objetivos planteados en la sección \ref{sec:objetivos} de la introducción. Se analizará hasta qué punto se han cumplido esos objetivos, así como qué aspectos se podrían mejorar. Las mejoras serán comentadas de forma breve, pues en el capítulo \ref{ch:futuro} se verán los trabajos futuros que se pueden aplicar a este proyecto. Se tratarán también los conocimientos aprendidos, así como la familiarización con nuevas tecnologías o herramientas empleadas en el desarrollo del proyecto. Por último, se finalizará el capítulo hablando de la relación del desarrollo del trabajo con los estudios cursados.


% CUMPLIMIENTO DE LOS OBJETIVOS

\section{Cumplimiento de los objetivos}
\label{sec:conc-objetivos}

En la formalización del problema, sección \ref{sec:formalizacion}, se relacionaron los objetivos que debía cumplir el sistema con tareas a más bajo nivel. De esta manera, se va a realizar la comprobación sobre el cumplimiento de los objetivos en base al nivel de cumplimiento de las tareas con las que se asociaron.


\subsection{Permitir que los usuarios modifiquen y vean los cambios en los documentos en tiempo real.}
\label{subsec:objetivos-conc-sincro}

El aspecto fundamental de este objetivo era conseguir la sincronización en tiempo real de los \textit{notebooks}. Una vez lograda esta soncronización, los usuarios serán capaces de ver los cambios realizados en los documentos o, en caso de tener permiso para hacerlo, modificarlos.

La sincronización en tiempo real de los documentos se ha conseguido llevar a cabo. Se ha utilizado la solución que hacía uso de la carga y guardado de \textit{notebooks} en disco, cuyo análisis se puede ver en la subsección \ref{subsec:sincro}. Este modelo es funcional, pero tiene aspectos de mejora, como pueden ser el consumo innecesario de recursos, pues se está haciendo un \textit{\gls{polling}} constante para cargar los archivos; así como el aumento de tiempo de interacción a medida que los \textit{notebooks} van siendo más pesados, ya que no da tiempo a que se carguen los documentos enteros dentro del intervalo especificado.

Una mejora a considerar sería, por ejemplo, la actualización únicamente de las celdas modificadas. Ésto arreglaría los dos problemas previamente comentados, pues si un documento no ha sido modificado en el intervalo de tiempo, no se cargaría nada, y, en el caso de haber modificaciones, el consumo de recursos sería pequeño independientemente del tamaño del documento. 

En conclusión, la sincronización de los \textit{notebooks} se ha conseguido, ya que hemos llegado a un punto donde se puede hacer uso de la plataforma sin que sea una gran inconveniencia. Sin embargo, hay margen de mejora, y se podría llegar a soluciones más eficientes, con un menor consumo de recursos y tiempo de espera. Por lo tanto, el sistema permite que los usuarios modifiquen y vean los cambios en los documentos en tiempo real.

\subsection{Gestionar los usuarios, sus permisos y sus sesiones.}
\label{subsec:objetivos-conc-roles}

A la hora de llevar a cabo este objetivo, se consideraron necesarias la autenticación, autorización e identificación de los usuarios en la plataforma, así como el guardado y mantenimiento de sus sesiones.

\subsubsection{Autenticación.}
\label{subsec:objetivos-conc-auth}

El objetivo de la autenticación se ha cumplido con creces. La plataforma \textit{Auth0} nos ofrece una autenticación segura y robusta, haciendo uso de tecnologías muy extendidas como \textit{OAuth}. Es una solución sencilla para los usuarios, ya que pueden utilizar la identificación de un tercero o bien crear una cuenta con su usuario y contaseña. 

\textit{Auth0} nos permite añadir más capas de seguridad, como aumentar los requisitos necesarios para las contraseñas en el sistema o utilizar verificación en dos pasos. No se ha hecho uso de estas opciones en la aplicación porque no se estiman necesarias, sin embargo, en caso de querer utilizarse, es tan sencillo como seleccionarlo en el menú de configuración de \textit{Auth0}, por lo que sería un cambio immediato.

Además, \textit{Auth0} permite el uso de su sistema hasta por 7000 usuarios activos al mes de forma gratuita\footnote{https://auth0.com/blog/announcing-our-new-pricing-including-a-production-ready-free-account/}. Se trata de una herramienta escalable, pero, en el caso de ser utilizada por más usuarios, pasaría a ser de pago. Por otro lado, facilita la administración de estos usuarios, pues ofrece la posibilidad de denegar el acceso a usuarios en concreto o de organizarlos en grupos.

En conclusión, la autenticación se ha realizado de una manera muy completa, utilizando tecnología sencilla, moderna y robusta.

\subsubsection{Autorización.}

La autorización se ha llevado a cabo mediante la creación de un sistema de roles. Este sistema de roles se ha implementado correctamente. Todos los permisos que se pretenden representar en la aplicación están incluídos en algún rol. Los roles están bien diferenciados y cumplen su función dentro del entorno colaborativo. 

El sistema que se ha implementado en el proyecto solo permite un editor a la vez. La colaboración se consigue pasando el rol de editor entre los diferentes usuarios, así como haciendo que todos ellos vean los cambios en tiempo real. Una de las mejoras que podría tener el sistema sería la posibilidad que se editara simultáneamente el documento por más de un usuario. Ésto es un tema delicado, pues el diseño de un sistema con más de un editor concurrente presenta diversas complicaciones. Esta idea se detallará en el capítulo \ref{ch:futuro}.

Por tanto, la autorización se puede considerar exitosa. En cuanto al modelo de interacción, el elegido es posible que resulte un poco simple y limitado, y sería un aspecto a mejorar en versiones futuras, aunque cumple su trabajo y permite una colaboración fluida. 

\subsubsection{Identificación.}

La identificación se obtiene mediante la plataforma \textit{Auth0}. Cuando un usuario se autentica mediante un proveedor de identidad externo, es este proveedor el que facilita el identificador público que se utilizará en \textit{Jupyter}. En el caso de utilizar a el propio \textit{Auth0} como proveedor de indentidad, los usuarios podrán elegir su identificador. 

Se trata de una solución sencilla, pero que cumple su cometido, que es el de identificar a los usuarios y poderlos reconocer dentro de la plataforma.

\subsubsection{Mantener las sesiones de los usuarios.}
\label{subsec:objetivos-conc-session}

El guardado de las sesiones de los usuarios se ha conseguido haciendo uso de \textit{cookies}. Se utiliza una \textit{cookie} que genera el servidor de \textit{notebooks}, y que funciona como identificador del usuario. Esta \textit{cookie} se almacena en la base de datos y obliga a que el usuario se vuelva a autenticar una vez caduca.

Se trata de una solución muy común para mantener las sesiones, y que, en el caso de nuestra aplicación, funciona correctamente. Por lo tanto, podemos decir que se ha cumplido la tarea.


\subsection{Gestionar los notebooks.}
\label{subsec:objetivos-conc-compartir}

La gestión de los documentos se ha conseguido, delegando sobre los usuarios con permisos de administración en cada documento la gestión de éste. Se pueden realizar todas las acciones disponibles en el \textit{Jupyter} original, como el borrado o renombrado de los \textit{notebooks}. Para conseguir una gestión completa en base a la necesidades del proyecto, se ha añadido la opción de la compartición de notebooks. 

Es posible compartir los documentos dentro de la plataforma, pero es un aspecto que esta sujeto a mejoras considerables. El sistema de compartición actual muestra una lista de usuarios registrados en la plataforma. De esta manera se puede seleccionar al usuario que se quiere invitar al documento para que pase a formar parte de él. Uno de los problemas que plantea este sistema es precisamente el hecho de que los usuarios que se quieren añadir a un documento tienen que estar obligatoriamente dados de alta en la plataforma.

Una solución para este problema sería disponer de la posibilidad de compartir el documento bien mediante un \textit{\gls{link}} o un correo electrónico, de esta manera se podría invitar a usuarios externos a la plataforma a participar en documentos, haciendo que se registraran a través del enlace recibido y aparecieran directamente como Espectadores en el documento en cuestión.

Por lo tanto, la compartición de los documentos es posible y funcional, aunque se podría mejorar para aumentar su versatilidad. Como el resto de aspectos de la gestión formaban parte del \textit{Jupyter} original, podemos concluir que se puede realizar una gestión completa de los \textit{notebooks} en el sistema al haber añadido este útimo.

\subsection{Soportar la colaboración en distintas sesiones de trabajo.}
\label{subsec:objetivos-conc-persistir}

El aspecto más importante a realizar para cumplir este objetivo ha sido implementar una capa de persistencia en el sistema. La persistencia de la información se ha conseguido mediante el uso de una base de datos. Cumple todas las funciones que se requieren para el componente, por lo que el objetivo queda bastante completo. En cuanto a las mejoras disponibles, por el momento no es necesario almacenar más información. En el caso de hacer falta, se debería rediseñar la estructura de tablas de la base de datos en función a la necesidad. 

En conclusión, la base de datos es una solución completa para el problema de la persistencia, y se puede modificar para adaptarse a la información necesaria en caso de que ésta cambiara. Al solucionar este problema, podrá colaborar en distintas sesiones de trabajo, cumpliéndose el objetivo.
 
% CONOCIMIENTOS ADQUIRIDOS

\section{Conocimientos adquiridos}
\label{sec:conocimientos-adquiridos}

A lo largo del desarrollo del proyecto he trabajado con tecnologías que no había tratado durante los cuatro años del grado. Ésto me ha hecho tener que investigarlas, leer sobre ellas, buscar ejemplos e intentar conocer su funcionamiento para poder utilizarlas en la aplicación que se desarrollaba. He seguido un procedimiento bastante autodidacta, aprendiendo por mí mismo a enfrentarme a un problema, buscar soluciones, compararlas y elegir aquella que mejor se adapte al problema planteado.

Por otro lado, he aprendido a trabajar en un entorno real y con una aplicación establecida y profesional. El hecho de tomar como punto de partida para el proyecto el repositorio de \textit{Jupyter} me ha ayudado a comprender la forma de trabajar de un equipo de expertos, me ha acercado al mundo del \textit{software} libre y me ha obligado a estructurar mejor mi código, siguiendo las guias de estilo de la plataforma. 

También me ha hecho crecer mucho, tanto a nivel personal como profesional llevar a cabo este proyecto en el ámbito de unas prácticas de empresa. Ha sido muy interesante contar con la asesoría y experiencia de mis tutores y compañeros a la hora de afrontar los problemas que se me planteaban en el desarrollo del trabajo, así como aprender de las metodologías y técnicas que ellos emplean. 

A continuación, mostraré una breve lista de aspectos concretos y tecnologías que he utilizado y aprendido a lo largo del proyecto:

\begin{itemize}

\item Funcionamiento y utilización de \textit{notebooks}, además de su estructura interna y ciclo de ejecución.

\item Profundización en el protocolo \textit{HTTP}, así como la creación de un servidor web y el uso de la herramienta \textit{Tornado}

\item Conocimiento de la plataforma \textit{Auth0}, su uso e integración en una aplicación, además del protocolo \textit{OAuth}.

\item Ampliación de mis conocimientos sobre bases de datos, así como la puesta en marcha y uso de una.

\item Trabajo con navegadores, \textit{HTML} y \textit{JavaScript} en ellos, además del uso y programación de \textit{cookies} 

\item Utilización y familiarización con \textit{LaTeX}\footnote{https://www.latex-project.org/}.
\end{itemize}

Pienso que este trabajo ha sido muy beneficioso para mí, pues he aprendido mucho de él. Todos estos aspectos mencionados anteriormente no los aprendí en el grado, pero si que he puesto en práctica muchas otras cosas aprendidas en ese periodo, como comentaré en la sección \ref{sec:estudios-cursados}.

% RELACIÓN DEL TRABAJO DESARROLLADO CON LOS ESTUDIOS CURSADOS

\section{Relación del trabajo desarrollado con los estudios cursados}
\label{sec:estudios-cursados}

Los conocimientos que adquirí en el grado en igeniería informática han tenido una gran importancia en el desarrollo de este proyecto. Desde mi punto de vista, la carrera me ha formado a un nivel básico en la gran mayoría de áreas de la informática, y ha profundizado en algunas de ellas, más concretamente en los campos relacionados con la rama que yo elegí, la computación. Dadas las características del proyecto, y su escasa afinidad con el temario cursado en la rama de computación, he hecho un uso más amplio de los conocimientos básicos y generales comentados previamente.

Haciendo un barrido de términos generales a específicos, los contenidos aprendidos en el grado que he aplicado en este trabajo han sido los siguientes: 

\begin{itemize}

\item \textbf{Programación}: Este proyecto habría sido imposible de llevar a cabo sin los conocimientos sobre programación que apredí. La programación es un concepto muy amplio, y la hemos tratado desde muchos puntos de vista en los estudios cursados, así que es complicado definir bien todos y cada uno de los aspectos que he utilizado. Algunos ejemplos son el uso de clases y objetos, la herencia o las estructuras de datos. En cuanto a lenguajes de programación, había trabajado ya con algunos de los utilizados, como son \textit{Python} y \textit{JavaScript}.

\item \textbf{Bases de datos}: En el transcurso de la carrera, había trabajado con bases de datos, lo que ha hecho que la implementación de este aspecto en concreto haya sido extremadamente sencilla. Ya conocía el lenguaje \textit{SQL}, así que he podido realizar las consultas sin que eso supusiera un gran esfuerzo. Es cierto que nunca había creado y puesto en marcha una base de datos desde cero, por lo que he ampliado mi conocimiento en ese punto.

\item \textbf{Diseño de \textit{software}}: Los conocimientos que aprendí sobre el desarrollo de \textit{software} han sido de gran importancia al diseñar la arquitectura del sistema, los componentes y sus interacciones. Es primordial esquematizar y planificar cómo se va a afrontar el problema antes de empezar a implementar la solución.

\item \textbf{Redes y mensajería}: Ha sido de gran ayuda el conocimiento sobre redes aprendido en el grado, pues he hecho uso de protocolos como el \textit{HTTP}. Aunque no había trabajado con este protocolo en mucho detalle, los conocimientos de la materia me han hecho más llevadero el proceso. En cuanto a la mensajería, he utilizado lo aprendido para comprender el funcionamiento de los mensajes entre el servidor y los kernels. De hecho, ya había trabajado específicamente con la herramienta \textit{ZeroMQ}.

\end{itemize}

A parte de los aspectos técnicos que aprendí, cabe destacar la importancia que tiene el hecho de trabajar la resolución de problemas. En el transcurso del grado, se insiste en que el alumnado se enfrente a problemas de manera independiente. De esta manera, cuando el alumno se enfrenta a un problema real, sabe por donde atacarlo y puede llegar a conclusiones y resultados por si mismo. Estos conocimientos han sido vitales para mí a la hora de realizar el trabajo, pues, a pesar de seguir una rutina de reuniones y tener un apoyo de los tutores en las decisiones técnicas, puede resultar abrumador plantear problemas sin tener un conocimiento básico de como empezar a resolverlos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                          TRABAJOS FUTUROS                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\chapter{Trabajos futuros}
\label{ch:futuro}


Tal y como se ha comentado en el capítulo \ref{ch:conclusiones}, existe  margen de mejora para la aplicación desarrollada. El objetivo principal, que era la creación de un entorno colaborativo para la computación interactiva se ha logrado, sin embargo, éste podría ser más completo. Se debe tener en cuenta que el Trabajo de Fin de Grado tiene una carga lectiva determinada, en concreto 12 créditos \textit{ECTS}, así como unos plazos establecidos, por lo que en algún momento se tiene que detener el desarrollo del proyecto. Éste ha sido el motivo principal por el que estos trabajos futuros que se expondrán a continuación no han podido ser incorporados en el trabajo realizado.

Los tres aspectos que disponen de un margen de mejora más amplio, desde mi punto de vista, son la sincronización de los \textit{notebooks}, el modelo de edición y ejecución de nuestra plataforma y la gestión de los \textit{notebooks}, en concreto la manera de compartirlos, como se comenta en las subsecciones \ref{subsec:objetivos-conc-sincro}, \ref{subsec:objetivos-conc-roles} y  \ref{subsec:objetivos-conc-compartir} respectivamente. Se han planteado y diseñado algunas mejoras para estos tres objetivos del proyecto, como vamos a ver en las secciones de este capítulo.


%MEJORAS EN LA SINCRONIZACIÓN DE NOTEBOOKS

\section{Mejoras en la sincronización de \textit{notebooks}}
\label{sec:mejoras-sincro}

Se ha tratado en diferentes apartados de la memoria, como en la subsección \ref{subsec:sincro} o en la sección \ref{sec:desarrollo-sincro}, la solución llevada a cabo en el proyecto frente al problema de la sincronización. Consiste en sincronizar los diferentes documentos mediante la carga y guardado en disco de éstos. 
Esta solución se puede mejorar, tanto en el aspecto de la eficiencia, consumiendo menos recursos, así como en velocidad, reduciendo el tiempo de espera que existe entre que una modificación es realizada hasta que es vista por los espectadores.

La mejora propuesta consiste en realizar la carga de los documentos celda por celda. En el sistema actual, se carga el documento entero cada vez, lo que quiere decir que independientemente de los cambios que se hagan, se va a tardar lo mismo, pues se realiza una carga del archivo al completo. Con el nuevo sistema, el tiempo de carga dependerá del tamaño de las modificaciones realizadas desde el último guardado. Como el intervalo de tiempo utilizado es tan solo de un segundo, se puede esperar que estos cambios sean pequeños generalmente. Además, como solamente se actualizan las celdas modificadas, en el caso de no haberse producido ningún cambio desde el último guardado, el \textit{notebook} directamente no se actualizará, por lo que se ahorrará en recursos en aquellos  ciclos en los que el \textit{notebook} no contemple cambios.

Para llevar a cabo esta mejora, se debe implementar un método de detectar qué celdas han sido alteradas y qué celdas permanecen iguales. Uno de los problemas que puede surgir es que las celdas no tienen una numeración explícita dentro del \textit{JSON}, simplemente se ordenan por orden de aparición. \textit{Jupyter} da la opción de cambiar el orden de las celdas o incluso de fusionar dos celdas en una. Ésto puede ser una fuente de problemas a la hora de realizar las actualizaciones celda por celda. Se puede detectar de manera sencilla qué celdas han sido modificadas, pero al no tener una numeración explícita, no se pueden relacionar en el caso de haber cambiado de orden. Por ejemplo, si se intercambia el orden de las celdas 1 y 2, acción que \textit{Jupyter} permite, el sistema actualizaría las dos celdas en el documento del espectador, en lugar de intercambiarlas, ya que detectaría que las dos han sido modificadas. Este caso no es problemático, porque se puede asumir el coste de actualizar dos celdas. Sin embargo, si se fusionan las dos primeras celdas de un documento, el sistema relacionaría la celda 1 del nuevo documento (originalmente celdas 1 y 2) con la celda 1 del antiguo, la celda 2 del nuevo (originalmente la 3) con la 2 del antiguo, etc. Ésto resultaría en una actualización total del documento, ya que, desde el punto de vista del sistema, se han cambiado todas las celdas. 

La solución a este problema es mantener las relaciones de igualdad entre celdas independientemente del lugar que ocupen en el documento, es decir, saber detectar si la antigua celda 4 es la nueva 5, analizando si algunas celdas han sido añadidas o eliminadas. Siguiendo este modelo, a la hora de cargar el nuevo notebook, para cada celda del antiguo se podrán realizar cuatro acciones:

\begin{itemize}

\item \textbf{Crear la celda}. En el caso en el que se detecte que una celda ha sido añadida en algún punto, moviendo todas las celdas posteriores, se tendrá que crear una nueva celda en el notebook espectador.

\item \textbf{Actualizar la celda}. Consiste en el borrado y cargado de la celda en cuestión, se dará en el caso de que la celda haya sido modificada, pues no afecta a la alineación del resto de celdas.

\item \textbf{Eliminar la celda}. Si una celda ha sido borrada por el editor, se deberá eliminar consecuentemente en el notebook del espectador.

\item \textbf{No alterar la celda}. En el caso de que la celda mantenga su posición y contenido, no hay realizar ninguna acción.

\end{itemize}

Para saber qué celdas se tienen que crear, actualizar o modificar, el proceso encargado de la comparación tiene que identificarlas y mandarlas para que el Espectador pueda actuar en consecuencia. 

\begin{figure}[H]
	\centering
  	\includegraphics[width=0.9\textwidth]{nueva-sincro.png}
  	\caption{Esquema del ciclo de ejecución de la nueva sincronización}
  	\label{fig:new-sync}
\end{figure}

El ciclo de ejecución de este nuevo modelo se puede apreciar en la Figura \ref{fig:new-sync}. Se puede ver como se envian los dos documentos al proceso de comparación, el \textit{notebook} del editor, que contiene los cambios realizados desde el último guardado, y el \textit{notebook master}, que es el \textit{notebook} guardado en el ciclo anterior (\textit{paso 1}). El proceso encargado de comparar los dos \textit{notebooks} (comparador) estudiará los cambios realizados en el \textit{notebook} Editor respecto al \textit{master} y los agrupará en celdas creadas, modificadas y eliminadas. creará tres \textit{arrays} con los índices de las celdas en cada caso y los enviará al Espectador (\textit{paso 2}). El Espectador se encargará de actualizar su versión del \textit{notebook} en base a las \textit{arrays} recibidas. Por último, se guardará el \textit{notebook} Editor en disco, para ser tratado como \textit{master} en la próxima iteración (\textit{paso 3}).


% MEJORAS EN LA EDICIÓN Y EJECUCIÓN DE LA PLATAFORMA

\section{Mejoras en la edición y ejecución de la plataforma}
\label{sec:mejoras-ejec}

El modelo de edición y ejecución de la aplicación ha sido comentado en la subsección \ref{subsec:identificacin-permisos} y la sección \ref{sec:desarrollo-roles}. Se trata de un modelo con tan solo un editor concurrente, en el que ese permiso se va pasando por los diferentes usuarios con acceso al notebook que se está editando para conseguir la colaboración. El modelo de ejecución se mantenía inalterado con respecto al \textit{Jupyter} original, pues al tener solamente un editor en cada momento, todas las ejecuciones de celdas van a ser secuenciales, es decir, independientemente del usuario que esté editando, en ese momento solo ese usuario podrá ejecutar las celdas del \textit{notebook}.

El modelo de ejecución de \textit{Jupyter} funciona de una forma peculiar, como se explicó en la subsección \ref{subsec:modelo-ejec}. Las celdas se ejecutan en base al contexto guardado en el \textit{Kernel} en el momento en el que se envian. Este contexto del \textit{Kernel} está formado por el estado asignado a las variables en las ejecuciones anteriores. 

Al solo poder ser editados los documentos por un usuario en el \textit{Jupyter} original, este modelo tiene sentido, porque es el usuario el que decide en que orden ejecuta las celdas, y, por tanto, el  responsable de llevar el control de el contexto en cada punto. En el momento en el que se pretende que más de un usuario pueda realizar ejecuciones en un mismo documento, el modelo de ejecución original de \textit{Jupyter} empieza a no cumplir su función de una forma efectiva, pues las ejecuciones de un usuario pueden romper el contexto que otro esperaba en cierto punto del \textit{notebook}.

Se propone la situación en que el usuario \textit{A} está editando la celda 3 del documento, y, a su vez, el usuario \textit{B} está modificando la celda 5. El usuario \textit{B} había preparado una variable llamada \textit{sol} en la celda 4, para su uso posterior. Si el usuario \textit{A} utiliza esa etiqueta para cualquier otra variable y ejecuta, cuando \textit{B} intente ejecutar la celda 5, su resultado no será el esperado, pues el valor de esa variable habrá cambiado en el contexto del \textit{kernel}, y se aplicará el último valor guardado, devolviendo un resultado diferente al esperado por \textit{B}.

Esta situación es dificil de resolver, porque se necesita que cada usuario pueda realizar las ejecuciones dentro del contexto que necesite, y, a su vez, que los espectadores puedan ver el progreso del \textit{notebook}. Si se continua funcionando como hasta ahora, se podría hacer que cada usuario tuviera una instancia del \textit{notebook} diferente, y asignar un \textit{kernel} a cada uno de ellos. De esta manera, cada usuario contaría con su contexto independiente, pero ¿cómo se mustra la información en tiempo real a los espectadores? ¿Y cómo se resuelven los conflictos que se puedan generar?, por ejemplo en el caso de que diferentes usuarios hayan modificado la misma celda. Estas preguntas no tienen una respuesta sencilla, por lo que se plantea la colaboración de dos o más usuarios simultáneos haciendo uso de un modelo diferente, en el cuál a cada usuario se le deja modificar únicamente una celda en cada momento.

De esta manera, el usuario con permisos de administración podría dar los permisos a celdas en concreto, haciendo que cada usuario solo pueda modificar una celda a la vez. Para que no haya conflictos en la ejecución, se mantendrá una versión \textit{master} del \textit{notebook}. Esta versión será la guardada en disco, y la correcta en cada momento dado. A la hora de conocer el contexto con el que está trabajando, el usuario siempre tendrá como referencia esta versión \textit{master}. Para que se produzcan modificaciones en ella, el usuario con permisos de administración en el \textit{notebook} tiene que aceptar los cambios realizados por un editor en la celda editada. Cuando se acepten, se actualizará la versión \textit{master}, y, de esta manera, se empujarán los cambios a todos los usuarios que estén editando, para que vean que el contexto ha cambiado y que les puede afectar.

\begin{figure}[H]
	\centering
  	\includegraphics[width=0.9\textwidth]{mejora_ejecucion.png}
  	\caption{Esquema del nuevo modelo de ejecución}
  	\label{fig:new-exec}
\end{figure}

En la Figura \ref{fig:new-exec} se puede ver un esquema de este nuevo modelo de edición y ejecución de nuestra plataforma. Se puede apreciar la versión \textit{Master} del notebook así como los diferentes colaboradores. Tambien se puede ver que aparece un elemento llamado \textit{kernel proxy}, que será el encargado de interceptar los mensajes entre los notebooks y el \textit{kernel} y añadir métodos de la herramienta \textit{Dill} \footnote{https://pypi.org/project/dill/} (Módulo de \textit{Python} que extiende las funcionalidades de \textit{Pickle}\footnote{https://docs.python.org/3/library/pickle.html}), que gestionará los contextos. Se hará uso de dos métodos, uno de carga y otro de guardado. El método de guardado, al llamarse en un punto del código, guarda el contexto del momento en que fué llamado en disco. Por otro lado, el de cargado, carga el método dado un archivo en disco y sobreescribe el contexto existente en base a este archivo. El \textit{kernel proxy} insertará estos métodos en lugares concretos del código mandado por los diferentes colaboradores para que éste sea ejecutado en base al contexto deseado. El funcionamiento del sistema es el siguiente:

En primer lugar se tiene que realizar una ejecución del \textit{notebook master} para generar los contextos. En el caso de que el \textit{notebook} sea nuevo y esté vacío no es necesario, porque no habrá contexto disponible. Este modelo de ejecución va a seguir la lógica de que el \textit{notebook} es lineal, es decir que las celdas inferiores siempre van a ejecutarse más tarde que la superiores. Al ejecutar el \textit{notebook master} completo, se mandan las celdas a ejecución una a una y en orden. Cada vez que el \textit{kernel proxy} reciba el código de una celda, le insertará un método \textit{Dill} de guardado al final y lo mandará a ejecutar. De esta manera, se almacenará el contexto de cada celda en la \textit{array} de contextos, que estará guardada en disco. 

Después, el administrador compartirá una celda, nombrando a un usuario editor. Cuando este usuario quiera realizar una ejecución de la celda, se mandará el código al \textit{kernel proxy}, y éste añadirá el método de cargado \textit{dill} al principio, cogiendo el archivo de contexto de la celda anterior a la que se va a mandar a ejecutar. De esta manera, el \textit{kernel} cargará el contexto correspondiente y la celda se ejecutará de forma consistente. El editor puede hacer pruebas, porque el contexto siempre va a ser el de la celda anterior en sus ejecuciones.

Por último, cuando un editor termine con las modificaciones en su celda, el administrador del \textit{notebook} tiene que decidir si mantiene los cambios o los descarta. En el caso de descartar los cambios propuestos, no se tiene que realizar ninguna ejecución, porque los contextos se mantienen. Sin embargo, en el caso de aceptar estas modificaciones, se tienen que recalcular los contextos de las celdas posteriores, porque dependen de éste. En el momento en el que se acepten los cambios, se ejecutará desde la celda cambiada hasta el final del documento.  En la primera celda que se ejecute, el \textit{kernel proxy} insertará el método \textit{dill} de carga al principio, cogiendo el archivo de contexto de la celda anterior, y el de guardado al final, para ejecutar las celdas en base al contexto correcto. El resto de celdas se ejecutarán con el método \textit{dill} de guardado al final. Para finalizar, se actualizarán los notebooks de los editores con un mensaje, avisando de que la versión \textit{master} ha cambiado, para que lo tengan en cuenta.

Este sistema funciona con un solo \textit{kernel}, por lo que el consumo de recursos es bajo. Sin embargo, en el caso de haber muchos editores y querer ejecutar sus celdas a la vez, algunos usuarios puede que tengan que esperar. Esto se debe a que el \textit{kernel} solo puede ejecutar una celda a la vez, por lo que el \textit{kernel proxy} tiene que implementar una cola, mandando una celda a ejecutar cuando el \textit{kernel} le haya devuelto un resultado y esté disponible. Por otro lado, se podría plantear un modelo con un \textit{kernel} por editor, cargando su contexto al principio. De esta manera el \textit{kernel proxy} serviría para dirigir cada celda a su \textit{kernel} asociado. Se debe valorar si interesa un sistema con poco tiempo de espera y poco consumo de recursos o si se prefiere un tiempo de respuesta menor con un coste computacional más elevado. De esto dependerá la topología elegida para el sistema mejorado.

%MEJORAS EN LA GESTIÓN DE NOTEBOOKS

\section{Mejoras en la gestión de \textit{notebooks}}
\label{sec:mejoras-gestión}

La gestión de notebooks mantiene todas las opciones de las que dispone la versión original de \textit{Jupyter}. Como se ha comentado en la subsección \ref{subsec:objetivos-conc-compartir}, se ha añadido la compartición de los \textit{notebooks} a estas opciones, ya que es necesaria dentro del entorno colaborativo. 

Esta opción para la compartición se ha llevado a cabo de manera funcional, dándole al administrador del \textit{notebook} en cuestión permiso para compartir éste con los diferentes usuarios registrados en la plataforma. La manera de lograrlo es seleccionando su identificador público en un submenú, como se puede apreciar en la figura \ref{fig:detalle-nb}. Este método plantea algunos problemas en el momento en el que hay muchos usuarios dados de alta en la plataforma, ya que puede ser tedioso encontrar al usuario concreto que se desea añadir. Una solución a este problema sería dar la posibilidad al administrador de buscar en la lista de usuarios, o bien poder añadir a un usuario insertando su identificador directamente. 

Para conseguir una compartición más completa, se debería poder añadir a usuarios a los \textit{notebooks} por correo electrónico o haciendo uso de \textit{links}. ésto permitiria compartir los documentos con gente todavía no registrada en el sistema. Habría que tener en cuenta la seguridad de estos métodos, pues, aunque los usuarios añadidos se dieran de alta en la plataforma, cosa que tendrían que hacer, habría que verificar que son quién dicen ser. De no poder realizar la comprobaciones de identidad necesarias, podrían llegar usuarios no deseados a visualizar los documentos, lo que supondría una gran vulnerabilidad. Para poder introducir estos métodos de compartición en la aplicación se debería realizar un estudio y escoger una solución segura.

La inclusión de todas estas mejoras mencionadas en el proyecto llevado a cabo resultaría en una solución más completa. Sin embargo, el trabajo se ha finalizado y se ha obtenido una herramienta que cumple con todos los objetivos planteados. A lo largo del proyecto se ha ido pensando en todo momento en como mejorar el sistema, es por eso que estas propuestas de trabajo futuro están tan detalladas, y sirven como un punto de partida muy acotado para la continuación del proyecto.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                GLOSARIO                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\printglossary[title=Glosario]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                BIBLIOGRAFIA                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{thebibliography}{10}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL D'ARTICLE                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibitem{Sandewall}
   Erik Sandewall.
   \newblock Programming in an Interactive Environment: the Lisp Experience.
   \newblock \textit{ACM Computing Surveys (CSUR)} 1978.
   
\bibitem{ipython}
  	F. Pérez, B.E. Granger.
	\newblock IPython: a system for interactive scientific computing.
	\newblock \textit{Computing in Science and Engineering} 21-29, 2007 

\bibitem{jupyter-nb}
  	T. Kluyver et al.
	\newblock Jupyter Notebooks – a publishing format for reproducible computational workflows
	\newblock \textit{20th International Conference on Electronic Publishing}, Enero 2016

\bibitem{context}
  	Anind K. Dey, Gregory D. Abowd.
	\newblock Towards a Better Understanding of Context and Context-Awareness.
	\newblock \textit{HUC '99 Proceedings of the 1st international symposium on Handheld and Ubiquitous Computing} 304-307, 1999

\bibitem{th-mathematica}
  	Brian Hayes.
	\newblock Thoughts on Mathematica.
	\newblock \textit{Pixel} 28-35, Enero-Febrero 1990
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL DE LLIBRE                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibitem{math}
   Wolfram S. 
   \newblock \textit{Mathematica}.
   \newblock Cambridge University Press; 1996.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MODEL D'URL                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibitem{wire-protocol}
	\textit{The wire protocol}, el protocolo de mensajería 
    cliente-\textit{kernel} de \textit{Jupyter}.
    \newblock Consultado el 19/06/2018 en
	\url{http://jupyter-client.readthedocs.io/en/stable/messaging.html}

\end{thebibliography}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           APÈNDIXS  (Si n'hi ha!)                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\APPENDIX


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              FI DEL DOCUMENT                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
